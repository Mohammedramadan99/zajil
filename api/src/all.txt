File structure:
./
├── certs/
│   ├── signerCert.pem*
│   ├── signerKey.key*
│   └── wwdr.pem*
├── common/
│   ├── interfaces/
│   │   ├── apple-card-props.ts*
│   │   ├── crud.controller.ts*
│   │   ├── jwt-payload.ts*
│   │   └── request.mod.ts*
│   └── index.ts*
├── config/
│   ├── config.interface.ts*
│   └── index.ts*
├── db/
│   ├── index.ts*
│   ├── init-models.ts*
│   └── set-associations.ts*
├── helpers/
│   └── index.ts*
├── middlewares/
│   ├── methods/
│   │   ├── account-activation.middleware.ts*
│   │   ├── auth.middleware.ts*
│   │   ├── canUseBusinessId.middleware.ts*
│   │   ├── handle404.middleware.ts*
│   │   ├── handleErrors.middleware.ts*
│   │   ├── logging.middleware.ts*
│   │   ├── response-formatter.middleware.ts*
│   │   └── validate.middleware.ts*
│   └── index.ts*
├── modules/
│   ├── apple-passes/
│   │   ├── consts/
│   │   │   └── index.ts*
│   │   ├── services/
│   │   │   └── index.ts*
│   │   └── utils/
│   │       └── index.ts*
│   ├── auth/
│   │   ├── controllers/
│   │   │   └── Auth.ts*
│   │   ├── dto/
│   │   │   └── login.ts*
│   │   └── services/
│   │       ├── index.ts*
│   │       └── jwt.ts*
│   ├── aws/
│   │   ├── index.ts*
│   │   └── s3.ts*
│   ├── branches/
│   │   ├── controllers/
│   │   │   └── Branches.ts*
│   │   ├── dto/
│   │   │   ├── create-branch.ts*
│   │   │   └── update-branch.ts*
│   │   ├── models/
│   │   │   └── branch.model.ts*
│   │   └── services/
│   │       └── index.ts*
│   ├── businesses/
│   │   ├── controllers/
│   │   │   ├── Business.ts*
│   │   │   └── menu.ts*
│   │   ├── dto/
│   │   │   ├── create-business.ts*
│   │   │   ├── create-menu.ts*
│   │   │   └── update-business.ts*
│   │   ├── models/
│   │   │   ├── menu/
│   │   │   │   ├── menu-item.model.ts*
│   │   │   │   └── menu.model.ts*
│   │   │   ├── activity.model.ts*
│   │   │   └── business.model.ts*
│   │   └── services/
│   │       ├── index.ts*
│   │       └── menu.services.ts*
│   ├── cards/
│   │   ├── controllers/
│   │   │   └── Card.ts*
│   │   ├── dto/
│   │   │   ├── validators/
│   │   │   │   └── stickers-len-e-value.ts*
│   │   │   ├── create-card.ts*
│   │   │   ├── items-sub-use.ts*
│   │   │   ├── loyalty-add-subtract-points.ts*
│   │   │   └── update-card.ts*
│   │   ├── models/
│   │   │   ├── card.model.ts*
│   │   │   ├── event-card.model.ts*
│   │   │   ├── items-subscription-card.model.ts*
│   │   │   └── loyalty-card.model.ts*
│   │   └── services/
│   │       └── index.ts*
│   ├── card-templates/
│   │   ├── controllers/
│   │   │   └── CardTemplate.ts*
│   │   ├── dto/
│   │   │   ├── create-card-template.ts*
│   │   │   ├── create-loyalty-gift.dto.ts*
│   │   │   └── update-card-template.ts*
│   │   ├── models/
│   │   │   ├── card-template.model.ts*
│   │   │   ├── event-ticket-template.model.ts*
│   │   │   ├── items-subscription-card-template.model.ts*
│   │   │   ├── loyalty-card-template.model.ts*
│   │   │   └── loyalty-gift.model.ts*
│   │   └── services/
│   │       └── index.ts*
│   ├── events/
│   │   ├── controllers/
│   │   │   └── events.ts*
│   │   ├── dto/
│   │   │   ├── create-event.ts*
│   │   │   └── update-event.ts*
│   │   ├── models/
│   │   │   └── event.model.ts*
│   │   └── services/
│   │       └── index.ts*
│   ├── file-upload/
│   │   ├── controllers/
│   │   │   └── file-upload.controller.ts*
│   │   ├── models/
│   │   │   └── file.model.ts*
│   │   └── services/
│   │       └── file-upload.service.ts*
│   ├── notifications/
│   │   ├── controllers/
│   │   │   └── notifications.controller.ts*
│   │   ├── dto/
│   │   │   └── create-notification.ts*
│   │   └── services/
│   │       ├── apn.service.ts*
│   │       └── notifications.service.ts*
│   ├── statistics/
│   │   ├── controllers/
│   │   │   └── statistics.controller.ts*
│   │   ├── dto/
│   │   │   ├── get-activities-chart.query.dto.ts*
│   │   │   ├── get-activities.query.dto.ts*
│   │   │   ├── get-cards-chart.query.dto.ts*
│   │   │   ├── get-cards.query.dto.ts*
│   │   │   ├── get-cards-rewards-redeemed-chart.query.dto.ts*
│   │   │   └── get-cards-total.query.dto.ts*
│   │   └── services/
│   │       └── statistics.service.ts*
│   └── users/
│       ├── controllers/
│       │   └── Users.ts*
│       ├── dto/
│       │   ├── create-user.ts*
│       │   └── update-user.ts*
│       ├── models/
│       │   └── user.model.ts*
│       └── services/
│           └── index.ts*
├── routes/
│   ├── branches.router.ts*
│   ├── businesses.router.ts*
│   ├── cards.router.ts*
│   ├── card-templates.router.ts*
│   ├── events.router.ts*
│   ├── file-upload.router.ts*
│   ├── index.ts*
│   ├── menu.router.ts*
│   ├── notifications.router.ts*
│   ├── statistics.router.ts*
│   └── users.router.ts*
├── all.txt*
├── app.ts*
└── index.ts*

app.ts:
```
	import Express from 'express';
	import { applyMiddlewaresPost, applyMiddlewaresPre } from './middlewares';
	import { handleErrors } from './middlewares/methods/handleErrors.middleware';
	import cors from 'cors';
	import mainRouter from './routes';
	import fileUpload from 'express-fileupload';
	import config from './config';
	
	const app = Express();
	app.use(config.apiPrefix, Express.static('public'));
	app.use(cors());
	app.use(Express.json());
	app.use(
	    fileUpload({
	        // 5MB
	        limits: { fileSize: 5 * 1024 * 1024 },
	    }),
	);
	applyMiddlewaresPre(app);
	app.use(config.apiPrefix, mainRouter);
	applyMiddlewaresPost(app);
	app.use(handleErrors);
	
	export default app;
```

certs/signerCert.pem:
```
	-----BEGIN CERTIFICATE-----
	MIIGFjCCBP6gAwIBAgIQLRactEhpNi5q/IG4repGNDANBgkqhkiG9w0BAQsFADB1
	MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBD
	ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTELMAkGA1UECwwCRzQxEzARBgNVBAoMCkFw
	cGxlIEluYy4xCzAJBgNVBAYTAlVTMB4XDTIzMDUyNjIyMzU0N1oXDTI0MDYyNDIy
	MzU0NlowgZExJTAjBgoJkiaJk/IsZAEBDBVwYXNzLmNvbS56YWppbC5wYXNzZXMx
	LDAqBgNVBAMMI1Bhc3MgVHlwZSBJRDogcGFzcy5jb20uemFqaWwucGFzc2VzMRMw
	EQYDVQQLDApBUkc5OVc5WUY2MRgwFgYDVQQKDA9IQVNTQU4gS0hVQlJBTkkxCzAJ
	BgNVBAYTAlVTMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAx4J1UtF0
	BY3unw3LXtNNsHmjlo6zGUvOpZtPBARJJ2cDXxw7iOQpIq1ApSytncjphkfTk6Ci
	Jc2n+BaarW6S09E/vfqJvtngR56MgZMokuPTwsd+0vDp0NsGZWHIb0KdwVGG1W9B
	kME4bi/69176k1GP6P11VE8qu2TxObgMfPISAc2oxLEfGngrJIAafILfyRcpCEAn
	PYuAFS4ndkoBmpd+GY8y7NjTkQ8iPAEHZWT8N91v05J/DGLfh+Et0HKL0oX1bNu8
	bna/3ymGaYRWRRWaVnaJE4LSc51J/IsRHVEcqWhKz/c/aTdADi6IusnfgYo4sdpa
	1AntG6bufDatdQIDAQABo4ICgzCCAn8wDAYDVR0TAQH/BAIwADAfBgNVHSMEGDAW
	gBRb2fod55oaC6OZdiJQhj6RyFt3qDBwBggrBgEFBQcBAQRkMGIwLQYIKwYBBQUH
	MAKGIWh0dHA6Ly9jZXJ0cy5hcHBsZS5jb20vd3dkcmc0LmRlcjAxBggrBgEFBQcw
	AYYlaHR0cDovL29jc3AuYXBwbGUuY29tL29jc3AwMy13d2RyZzQwNDCCAR4GA1Ud
	IASCARUwggERMIIBDQYJKoZIhvdjZAUBMIH/MIHDBggrBgEFBQcCAjCBtgyBs1Jl
	bGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMg
	YWNjZXB0YW5jZSBvZiB0aGUgdGhlbiBhcHBsaWNhYmxlIHN0YW5kYXJkIHRlcm1z
	IGFuZCBjb25kaXRpb25zIG9mIHVzZSwgY2VydGlmaWNhdGUgcG9saWN5IGFuZCBj
	ZXJ0aWZpY2F0aW9uIHByYWN0aWNlIHN0YXRlbWVudHMuMDcGCCsGAQUFBwIBFito
	dHRwczovL3d3dy5hcHBsZS5jb20vY2VydGlmaWNhdGVhdXRob3JpdHkvMB4GA1Ud
	JQQXMBUGCCsGAQUFBwMCBgkqhkiG92NkBA4wMgYDVR0fBCswKTAnoCWgI4YhaHR0
	cDovL2NybC5hcHBsZS5jb20vd3dkcmc0LTEuY3JsMB0GA1UdDgQWBBS0EuxEVZXP
	ftDfcCisZ33vcI00WTAOBgNVHQ8BAf8EBAMCB4AwJQYKKoZIhvdjZAYBEAQXDBVw
	YXNzLmNvbS56YWppbC5wYXNzZXMwEAYKKoZIhvdjZAYDAgQCBQAwDQYJKoZIhvcN
	AQELBQADggEBAECdIrcderDTjuUBfc8/m8d0fZjFX41dSrkwc8BIp7nCuuHUsN/l
	Hfx/IHXOiRGqQcOZBH074AR54zq4a0cbSc4NViv4rIWoSEavfGqzrq5HMljeZSXx
	bGLc/SNeQaNSIQWw1b+br/4QsmQG62VwA8kpQiKepFatLr/dwl69BW66WAE3n7Ct
	7xeJwBNKqglU92iG/0knbiAit7XUSQSxwsYrfHCg9fSpItsBL3+GB300X71ykenk
	KAKhSc75pRJ1WuvbTPcNgg+iId79oDY/61QQ+SJ09ULhxUKFIRW/QyDdoX9/R7U5
	hnhJrw3ybLm0p2P0WHwBmPMPxVfQ8RCK+/4=
	-----END CERTIFICATE-----
```

certs/signerKey.key:
```
	-----BEGIN PRIVATE KEY-----
	MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDHgnVS0XQFje6f
	Dcte002weaOWjrMZS86lm08EBEknZwNfHDuI5CkirUClLK2dyOmGR9OToKIlzaf4
	FpqtbpLT0T+9+om+2eBHnoyBkyiS49PCx37S8OnQ2wZlYchvQp3BUYbVb0GQwThu
	L/r3XvqTUY/o/XVUTyq7ZPE5uAx88hIBzajEsR8aeCskgBp8gt/JFykIQCc9i4AV
	Lid2SgGal34ZjzLs2NORDyI8AQdlZPw33W/Tkn8MYt+H4S3QcovShfVs27xudr/f
	KYZphFZFFZpWdokTgtJznUn8ixEdURypaErP9z9pN0AOLoi6yd+Bijix2lrUCe0b
	pu58Nq11AgMBAAECggEAJD0OEnz5FgkxzrIyvoajFesCS9afsXiTkIElWRVuNDoB
	4sS+C59l2Wae12HGJ2LXCA0D4UzMJxGz8NwqPFZZVSAs89UOMBxjIJ8r5l1UgVng
	nQCfiLE5xzYBc2jPf2YaQYMNerc6sZBnL5yHeWdHHHs0KJ3hMe8vU9qB9nn3yrna
	71pjlo7H+5NGT/+DnKVy821P7pwFAQpaeYHZEn9RrxmXkAHl0XqzvLAgJMoEMUfX
	G6LJhN9yNaiFXCh4Uw5Dg8CjuchoBEYl/BT2FJPjy4zFZVxZsw0s41BwpnhuM5Jw
	WqXZF5Y+d1oqsditJkKZcKTPrsbY0kbvBTauSI8OAQKBgQD8nceOS5APWCsLj45P
	D5teZ9jLrQHcbG4BLFes5CReeg0Vhr+TMx8jeKtGhhDm1md4v+xfPOvhEC4VxFsP
	e93f7j4Ex02HNTpsoO4vxHnPaZXVm4GS6gIthR5aM1WKxwOVv3Mvpukof5UuqU1t
	Xsj90Ij22G1N7gf7qvg/BRUARwKBgQDKLpN1orZtIK7NnnQgJzQ+x8aM7ZEjp36f
	29d0oMMjgVSWeX1DF/5klN27muF7f5d70uliUPPiWTkGOOdl/xsRWo6pMl6vcgye
	5ODMHfHqp4epgGy5RZHZkPY/zzUUh9ZjiSLKAuAyJamYBHZ2OJFneJzG7vaFefhH
	43wHkVbeYwKBgAdokSupJ6ZrjYefRCspaAMSxJbkkgNm4qsCI+gcILzsk2moNAIb
	I7Skm1FMKT671vkBl+sLHFfTY6abxZfkqBMjJ4p4Vdu7QeVhqtqXxoLAs/Y5w0kN
	t9ah6sv2aXHSeFZx8Oza1kerxjJCINUuTHK1JO8oVbxNWMqWrwUaHw2NAoGADQZf
	HY7z7afTWw/AL2oXJYw9MEsFtKRPtgC1qp/Isnrcdi0xcqcTDmvAtRtPN2OK4ME/
	o8PPUl+pGsuDrMB4f++zjRbfnrHcOkhIax3qvdE5HiRV3MGsmbWLB6VTqBTwLM1i
	3ly9EL34ZQC0mP0f8OiGQRKX8xVed1MiZGJqlD0CgYEAynSNsbSiV1xuORvmBkBO
	l5PfpF9q80t+eAgkKRa3e5qXBBdJNviQSzkV1aEoG66SK2ErkP8Af1mIsAN/Z54W
	xyyYHF3ih4PbOrja0NEQ/r9vqREs4tsLXqlj/NxuhIE+Yh20fht+Hl5vjyLik53Z
	R+4OJIkz7H1MxY6WUoF8atM=
	-----END PRIVATE KEY-----
```

certs/wwdr.pem:
```
	-----BEGIN CERTIFICATE-----
	MIIEVTCCAz2gAwIBAgIUE9x3lVJx5T3GMujM/+Uh88zFztIwDQYJKoZIhvcNAQEL
	BQAwYjELMAkGA1UEBhMCVVMxEzARBgNVBAoTCkFwcGxlIEluYy4xJjAkBgNVBAsT
	HUFwcGxlIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRYwFAYDVQQDEw1BcHBsZSBS
	b290IENBMB4XDTIwMTIxNjE5MzYwNFoXDTMwMTIxMDAwMDAwMFowdTFEMEIGA1UE
	Aww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNh
	dGlvbiBBdXRob3JpdHkxCzAJBgNVBAsMAkc0MRMwEQYDVQQKDApBcHBsZSBJbmMu
	MQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANAf
	eKp6JzKwRl/nF3bYoJ0OKY6tPTKlxGs3yeRBkWq3eXFdDDQEYHX3rkOPR8SGHgjo
	v9Y5Ui8eZ/xx8YJtPH4GUnadLLzVQ+mxtLxAOnhRXVGhJeG+bJGdayFZGEHVD41t
	QSo5SiHgkJ9OE0/QjJoyuNdqkh4laqQyziIZhQVg3AJK8lrrd3kCfcCXVGySjnYB
	5kaP5eYq+6KwrRitbTOFOCOL6oqW7Z+uZk+jDEAnbZXQYojZQykn/e2kv1MukBVl
	PNkuYmQzHWxq3Y4hqqRfFcYw7V/mjDaSlLfcOQIA+2SM1AyB8j/VNJeHdSbCb64D
	YyEMe9QbsWLFApy9/a8CAwEAAaOB7zCB7DASBgNVHRMBAf8ECDAGAQH/AgEAMB8G
	A1UdIwQYMBaAFCvQaUeUdgn+9GuNLkCm90dNfwheMEQGCCsGAQUFBwEBBDgwNjA0
	BggrBgEFBQcwAYYoaHR0cDovL29jc3AuYXBwbGUuY29tL29jc3AwMy1hcHBsZXJv
	b3RjYTAuBgNVHR8EJzAlMCOgIaAfhh1odHRwOi8vY3JsLmFwcGxlLmNvbS9yb290
	LmNybDAdBgNVHQ4EFgQUW9n6HeeaGgujmXYiUIY+kchbd6gwDgYDVR0PAQH/BAQD
	AgEGMBAGCiqGSIb3Y2QGAgEEAgUAMA0GCSqGSIb3DQEBCwUAA4IBAQA/Vj2e5bbD
	eeZFIGi9v3OLLBKeAuOugCKMBB7DUshwgKj7zqew1UJEggOCTwb8O0kU+9h0UoWv
	p50h5wESA5/NQFjQAde/MoMrU1goPO6cn1R2PWQnxn6NHThNLa6B5rmluJyJlPef
	x4elUWY0GzlxOSTjh2fvpbFoe4zuPfeutnvi0v/fYcZqdUmVIkSoBPyUuAsuORFJ
	EtHlgepZAE9bPFo22noicwkJac3AfOriJP6YRLj477JxPxpd1F1+M02cHSS+APCQ
	A1iZQT0xWmJArzmoUUOSqwSonMJNsUvSq3xKX+udO7xPiEAGE/+QF4oIRynoYpgp
	pU8RBWk6z/Kf
	-----END CERTIFICATE-----
```

common/index.ts:
```
	import http from 'http';
	
	export class HttpError extends Error {
	    status: number;
	    constructor(status: number, message?: string | object) {
	        if (typeof message === 'object') {
	            message = JSON.stringify(message);
	        }
	
	        super(message || http.STATUS_CODES[status] || 'Error');
	        this.status = status;
	    }
	}```

common/interfaces/apple-card-props.ts:
```
	import { Field } from 'passkit-generator';
	import { BarcodeFormat } from 'passkit-generator/lib/schemas';
	
	export interface IAppleCardProps {
	    type: 'generic';
	    formatVersion: any;
	    passTypeIdentifier: string;
	    teamIdentifier: string;
	    serialNumber: string;
	    description: string;
	    organizationName: string;
	    logoText?: string;
	    backgroundColor?: string;
	    foregroundColor?: string;
	    headerFields?: Field[];
	    primaryFields?: Field[];
	    secondaryFields?: Field[];
	    auxiliaryFields?: Field[];
	    backFields?: Field[];
	    barcode: {
	        message: string;
	        format: BarcodeFormat;
	        messageEncoding?: string;
	    };
	    webServiceURL?: string;
	    authenticationToken?: string;
	}
```

common/interfaces/crud.controller.ts:
```
	import { Request, Response, NextFunction } from "express";
	
	export default interface ICRUDController {
	  create(req: Request, res: Response, next?: NextFunction): void;
	  getAll(req: Request, res: Response, next?: NextFunction): void;
	  getOne(req: Request, res: Response, next?: NextFunction): void;
	  update(req: Request, res: Response, next?: NextFunction): void;
	  delete(req: Request, res: Response, next?: NextFunction): void;
	}
```

common/interfaces/jwt-payload.ts:
```
	export interface IJWTPayload {
	    userId: number;
	    firstName: string;
	    lastName: string;
	    email: string;
	    businesses: number[];
	    roles: string[];
	    employedAt: number[];
	}
```

common/interfaces/request.mod.ts:
```
	import { Request } from 'express';
	import { User } from '../../modules/users/models/user.model';
	
	export type RequestMod = Request & {
	    user: User
	};
```

config/config.interface.ts:
```
	export interface ConfigInterface {
	    port: number;
	    host: string;
	    apiPrefix: string;
	    bcrypt: {
	        saltRounds: number;
	    };
	    JWT: {
	        secret: string;
	        expiresIn: string;
	    };
	    db: {
	        uri: string;
	        logging: boolean;
	        sync: boolean;
	        syncForce: boolean;
	        syncAlter: boolean;
	    };
	    applePasses: {
	        webServiceURL: string;
	    };
	    aws: {
	        secretAccessKey: string;
	        accessKeyId: string;
	        region: string;
	        s3: {
	            bucketName: string;
	        };
	    };
	}
```

config/index.ts:
```
	require('dotenv').config();
	import { ConfigInterface } from './config.interface';
	
	const config: ConfigInterface = {
	    port: parseInt(process.env.PORT, 10) || 3000,
	    host: process.env.HOST || 'localhost',
	    apiPrefix: process.env.API_PREFIX || '/api',
	    bcrypt: {
	        saltRounds: parseInt(process.env.BCRYPT_SALT_ROUNDS, 10) || 10,
	    },
	    JWT: {
	        secret: process.env.JWT_SECRET,
	        expiresIn: process.env.JWT_EXPIRES_IN || '1d',
	    },
	    db: {
	        uri: process.env.DB_URI,
	        logging: process.env.DB_LOGGING === 'true',
	        sync: process.env.DB_SYNC === 'true',
	        syncForce: process.env.DB_SYNC_FORCE === 'true',
	        syncAlter: process.env.DB_SYNC_ALTER === 'true',
	    },
	    applePasses: {
	        webServiceURL: process.env.APPLE_PASSES_WEB_SERVICE_URL,
	    },
	    aws: {
	        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
	        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
	        region: process.env.AWS_REGION,
	        s3: {
	            bucketName: process.env.AWS_S3_BUCKET_NAME,
	        },
	    },
	};
	
	export default config;
```

db/index.ts:
```
	import { Sequelize } from 'sequelize';
	import config from '../config';
	
	import { setAssociations } from './set-associations';
	import { initModels } from './init-models';
	
	const sequelize = new Sequelize(config.db.uri, {
	    logging: config.db.logging ? console.log : false,
	});
	
	// initialize models
	initModels(sequelize);
	
	// setup model associations
	setAssociations();
	
	// connect to the database
	const dbConnect = async () => {
	    await sequelize.authenticate();
	    console.log('Connection has been established successfully.');
	
	    console.log('Models', sequelize.models);
	
	    // default false
	    if (config.db.sync)
	        await sequelize.sync({
	            alter: config.db.syncAlter, // default false
	            force: config.db.syncForce, // default false
	        });
	
	    console.log('All models were synchronized successfully.');
	};
	
	export { sequelize, dbConnect };
```

db/init-models.ts:
```
	import * as path from 'path';
	import glob from 'glob';
	import { Sequelize } from 'sequelize';
	
	export const initModels = (sequelize: Sequelize) => {
	    // find all .model.ts files in the src.modules folders and sub folders
	    const files = glob.sync('**/*.model.{ts,js}', {
	        cwd: path.join(__dirname, '../modules'),
	    });
	
	    // import each model and call its init() function
	    files.forEach((file) => {
	        const model = require(path.join(__dirname, '../modules', file));
	        model.init(sequelize);
	    });
	};
```

db/set-associations.ts:
```
	import glob from 'glob';
	import * as path from 'path';
	
	export const setAssociations = () => {
	    // find all .model.ts files in the src.modules folders and sub folders
	    const files = glob.sync('**/*.model.{ts,js}', {
	        cwd: path.join(__dirname, '../modules'),
	    });
	
	    // import each model and call its associate() function
	    files.forEach((file) => {
	        const model = require(path.join(__dirname, '../modules', file));
	        model.associate();
	    });
	};
```

helpers/index.ts:
```
	import { plainToClassFromExist, plainToInstance } from 'class-transformer';
	import { ValidationError, validateSync } from 'class-validator';
	import bcrypt from 'bcrypt';
	import config from '../config';
	import { HttpError } from '../common';
	import { sign, verify } from 'jsonwebtoken';
	import { User } from '../modules/users/models/user.model';
	import { NextFunction } from 'express';
	import { writeFileSync } from 'fs';
	import { uploadFile } from '../modules/aws/s3';
	
	// validate DTO
	export const validateDto = (DtoClass: any, body: any) => {
	    let createItemDto = plainToInstance(DtoClass, body) as any;
	    let errors = validateSync(createItemDto, { whitelist: true });
	
	    if (errors.length > 0) {
	        errors = formatDtoValidationErrors(errors);
	
	        throw new HttpError(400, {
	            errors: errors,
	        });
	    }
	
	    return createItemDto;
	};
	
	const formatDtoValidationErrors = (errors: ValidationError[]) => {
	    return errors.map((error) => {
	        const { property, constraints } = error;
	        let { children } = error;
	
	        if (constraints) {
	            const out: any = {};
	            out[property] = Object.values(constraints);
	            return out;
	        }
	
	        if (children) {
	            // return the index as part of the property name
	            children = children.map((child) => {
	                child.property = `${property}.${child.property}`;
	                return child;
	            });
	
	            return formatDtoValidationErrors(children);
	        }
	
	        return null;
	    });
	};
	
	export const hashPassword = (password: string) => {
	    return bcrypt.hashSync(password, config.bcrypt.saltRounds);
	};
	
	export const comparePasswords = (password: string, hashedPassword: string) => {
	    return bcrypt.compareSync(password, hashedPassword);
	};
	
	// sign JWT for user account activation
	export const signUserAccountActivationToken = (userId: number) => {
	    return sign(
	        {
	            userId,
	            type: 'account-activation',
	        },
	        config.JWT.secret,
	        {
	            // expires in 10 days
	            expiresIn: 864000,
	        },
	    );
	};
	
	// verify JWT for user account activation
	export const verifyUserAccountActivationToken = (token: string) => {
	    let payload: any;
	
	    try {
	        payload = verify(token, config.JWT.secret);
	        if (payload.type !== 'account-activation') throw new Error('Invalid token');
	    } catch (error) {
	        throw new HttpError(400, error.message);
	    }
	
	    return payload.userId;
	};
	
	// send account activation email
	export const sendAccountActivationEmail = async (user: User) => {
	    const token = signUserAccountActivationToken(user.id);
	
	    console.log(`To activate your account, please click on the following link: /activate-account/${token}`);
	
	    // #TODO: send email
	};
	
	export const handleControllerServiceError = (next: NextFunction) => {
	    return (error: any) => {
	        if (error instanceof HttpError) {
	            next(error);
	        }
	
	        next(new HttpError(500, error.message));
	    };
	};
	
	export const downloadImageToFolder = async (imageURL: string, path: string) => {
	    // check if the url is for an image
	    const imageType = await fetch(imageURL, {
	        method: 'HEAD',
	    }).then((res) => res.headers.get('content-type'));
	    // if (!imageType || !imageType.includes('image')) throw new HttpError(400, 'Invalid image URL');
	
	    console.log(path.split('/').slice(0, -1).join('/'));
	
	    // download the image
	    return fetch(imageURL)
	        .then((x) => x.arrayBuffer())
	        .then((x) =>
	            uploadFile(
	                {
	                    name: path.split('/').pop() || '',
	                    data: Buffer.from(x),
	                    contentType: imageType || undefined,
	                },
	                path.split('/').slice(0, -1).join('/'),
	            ),
	        );
	};
```

index.ts:
```
	import 'reflect-metadata';
	import app from './app';
	import config from './config';
	import { dbConnect } from './db';
	
	const main = async () => {
	    await dbConnect().catch((err) => {
	        console.error(err);
	        process.exit(1);
	    });
	
	    app.listen(config.port, config.host, () => {
	        console.log(`App listening on ${config.host}:${config.port}`);
	    });
	};
	
	main().catch((err) => {
	    console.error(err);
	    process.exit(1);
	});
```

middlewares/index.ts:
```
	import { Express } from 'express';
	import conditional from 'express-conditional-middleware';
	
	import loggingMiddleware from './methods/logging.middleware';
	import responseFormatterMiddleware from './methods/response-formatter.middleware';
	import authMiddleware from './methods/auth.middleware';
	import handle404Middleware from './methods/handle404.middleware';
	import accountActivationMiddleware from './methods/account-activation.middleware';
	
	const midsPre = [loggingMiddleware, responseFormatterMiddleware, authMiddleware, accountActivationMiddleware];
	const midsPost = [handle404Middleware];
	
	// applys middlewares before the main router
	export const applyMiddlewaresPre = (app: Express) =>
	    midsPre.forEach((mid) => app.use(conditional(mid.condition, mid.middleware)));
	
	// applys middlewares after the main router
	export const applyMiddlewaresPost = (app: Express) =>
	    midsPost.forEach((mid) => app.use(conditional(mid.condition, mid.middleware)));
```

middlewares/methods/account-activation.middleware.ts:
```
	import { NextFunction, Response } from 'express';
	import { HttpError } from '../../common';
	import { RequestMod } from '../../common/interfaces/request.mod';
	
	// check if user account is activated
	const accountActivationMiddleware = async (req: RequestMod, res: Response, next: NextFunction) => {
	    try {
	        // Get the user from the request
	        const user = req.user;
	
	        // Check if user account is activated
	        if (!user.active) throw new Error('User account is not activated');
	
	        next();
	    } catch (error) {
	        next(new HttpError(401, error.message));
	    }
	};
	
	export default {
	    middleware: accountActivationMiddleware,
	    condition: (req: RequestMod, res: Response, next: NextFunction) => {
	        const exceptRegex = [
	            /\/login/,                        // /login
	            /\/register/,                     // /register
	            /\/activate-account/,             // /activate-account
	            /\/request-account-activation/,   // /request-account-activation
	            /\/businesses\/\d+\/cards/,       // /businesses/:id/cards
	            /\/v1\/.*/,                       // /v1/*
	        ]
	
	        return !exceptRegex.some((regex) => regex.test(req.path));
	    },
	};
```

middlewares/methods/auth.middleware.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import { HttpError } from '../../common';
	import { RequestMod } from '../../common/interfaces/request.mod';
	import { IJWTPayload } from '../../common/interfaces/jwt-payload';
	import { findOneUserById } from '../../modules/users/services';
	import { verifyJWT } from '../../modules/auth/services/jwt';
	
	const authMiddleware = async (req: RequestMod, res: Response, next: NextFunction) => {
	    try {
	        // Get the authorization header
	        const authHeader = req.headers.authorization;
	        if (!authHeader) throw new Error('Authorization header is required');
	
	        // Get the token
	        const token = authHeader.split(' ')[1];
	        if (!token) throw new Error('Access token required');
	
	        // Verify the token
	        const decoded: IJWTPayload = verifyJWT(token);
	
	        // Get the user from the database
	        const user = await findOneUserById(decoded.userId);
	        if (!user) throw new Error('User not found');
	
	        // Attach the user to the request
	        req.user = user;
	
	        next();
	    } catch (error) {
	        next(new HttpError(401, error.message));
	    }
	};
	
	export default {
	    middleware: authMiddleware,
	    condition: (req: RequestMod, res: Response, next: NextFunction) => {
	        const exceptRegex = [
	            /\/login/,                                            // /login
	            /\/register/,                                         // /register
	            /\/activate-account/,                                 // /activate-account
	            { path: /\/businesses\/\d+\/cards/, method: 'POST' }, // /businesses/:id/cards
	            /\/v1\/.*/,                                           // /v1/*
	        ];
	
	        return !exceptRegex.some((regex) => {
	            if (regex instanceof RegExp) {
	                return regex.test(req.path);
	            } else {
	                return regex.path.test(req.path) && regex.method === req.method;
	            }
	        });
	    },
	};
```

middlewares/methods/canUseBusinessId.middleware.ts:
```
	import { HttpError } from '../../common';
	import { RequestMod } from '../../common/interfaces/request.mod';
	
	export const canUseBusinessId = (req: RequestMod, res, next) => {
	    const businessId = Number(req.params.businessId);
	    const userBusinesses = req.user.businesses.map((business) => business.id);
	    if (userBusinesses.includes(businessId)) {
	        next();
	    } else {
	        next(new HttpError(403, 'This business does not belong to the user'));
	    }
	};
```

middlewares/methods/handle404.middleware.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import { HttpError } from '../../common';
	
	const handle404 = (req: Request, res: Response, next: NextFunction) => {
	    const err = new HttpError(404, 'Not Found');
	    next(err);
	};
	
	export default {
	    middleware: handle404,
	    condition: true, // all routes
	};
```

middlewares/methods/handleErrors.middleware.ts:
```
	import { error } from 'console';
	import { NextFunction, Request, Response } from 'express';
	
	export const handleErrors = (err: any, req: Request, res: Response, next: NextFunction) => {
	    try {
	        err.message = JSON.parse(err.message);
	    } catch (error) {}
	
	    res.status(err.status || 500).json({
	        status: err.status || 500,
	        message: err.message || 'Internal Server Error',
	    });
	
	    error(err);
	};```

middlewares/methods/logging.middleware.ts:
```
	import { NextFunction, Request, Response } from 'express';
	
	const LoggingMiddleware = (req: Request, res: Response, next: NextFunction) => {
	    console.log(`${req.method} ${req.path}`);
	    next();
	};
	
	export default {
	    middleware: LoggingMiddleware,
	    condition: true, // all routes
	};```

middlewares/methods/response-formatter.middleware.ts:
```
	import { NextFunction, Request, Response } from 'express';
	
	// This middleware is used to format the response body
	const responseFormatterMiddleware = (req: Request, res: Response, next: NextFunction) => {
	    const originalSend = res.send;
	
	    res.send = function (body) {
	        try {
	            // Parse the body into an object
	            body = JSON.parse(body);
	        } catch (error) {}
	
	        // Create the response body
	        const responseBody = JSON.stringify({ data: body });
	
	        // Set the response header
	        res.header('Content-Type', 'application/json');
	
	        // Return the original send function with the formatted body
	        return originalSend.call(this, responseBody);
	    };
	
	    next();
	};
	
	export default {
	    middleware: responseFormatterMiddleware,
	    condition: true, // all routes
	};
```

middlewares/methods/validate.middleware.ts:
```
	import { validateDto } from '../../helpers';
	
	export const validateMiddleware =
	    (dto: any, isQuery: boolean = false) =>
	    (req: any, res: any, next: any) => {
	        const body = validateDto(dto, isQuery ? req.query : req.body);
	        
	        isQuery ? (req.query = body) : (req.body = body);
	        next();
	    };
```

modules/apple-passes/consts/index.ts:
```
	import { IAppleCardProps } from '../../../common/interfaces/apple-card-props';
	
	export const APPLE_PASS_TYPE_IDENTIFIER = 'pass.com.zajil.passes';
	export const APPLE_TEAM_IDENTIFIER = 'ARG99W9YF6';
	
	export const APPLE_PASS_PLACEHOLDER = ({
	    serialNumber,
	    description,
	    organizationName,
	    qrCodeMessage,
	    qrCodeFormat,
	    designType,
	}): IAppleCardProps => ({
	    type: designType,
	    formatVersion: '1',
	    passTypeIdentifier: APPLE_PASS_TYPE_IDENTIFIER,
	    teamIdentifier: APPLE_TEAM_IDENTIFIER,
	    serialNumber: serialNumber,
	    description: description,
	    organizationName: organizationName,
	    barcode: {
	        message: qrCodeMessage,
	        format: qrCodeFormat || 'PKBarcodeFormatQR',
	    },
	});
```

modules/apple-passes/services/index.ts:
```
	import { promises as fs, writeFileSync } from 'fs';
	import path from 'path';
	import { PKPass } from 'passkit-generator';
	import {
	    getCertificates,
	    itemsSubGenerateStickersIfPossible,
	    loyaltyGenerateStickersIfPossible,
	    populateVariables,
	} from '../utils';
	import { IAppleCardProps } from '../../../common/interfaces/apple-card-props';
	import { signApplePassAuthTokens } from '../../auth/services/jwt';
	import config from '../../../config';
	import { getFile, s3LocationToKey } from '../../aws/s3';
	import { CardTemplate, CardType } from '../../card-templates/models/card-template.model';
	import { Business } from '../../businesses/models/business.model';
	
	export async function generatePass(props: { cardTemplateId: number; cardId: string }) {
	    const cardTemplate = await CardTemplate.findByPk(props.cardTemplateId, {
	        include: [
	            {
	                model: Business,
	                as: 'business',
	            },
	        ],
	    });
	
	    const appleJSON = cardTemplate.design;
	    const [certificates] = await Promise.all([getCertificates()]);
	
	    // get images from the card template folder
	    const [icon, logo, thumbnail, footer, strip, background] = await Promise.all([
	        getFile(s3LocationToKey(cardTemplate.iconUrl)),
	        getFile(s3LocationToKey(cardTemplate.logoUrl)),
	        getFile(s3LocationToKey(cardTemplate.thumbnailUrl)).catch(() => null),
	        getFile(s3LocationToKey(cardTemplate.footerUrl)).catch(() => null),
	        getFile(s3LocationToKey(cardTemplate.stripUrl)).catch(() => null),
	        getFile(s3LocationToKey(cardTemplate.backgroundUrl)).catch(() => null),
	    ]);
	
	    const appleJSONObj: IAppleCardProps = JSON.parse(
	        await populateVariables(JSON.stringify(appleJSON), Number(props.cardId)),
	    );
	
	    const pass = new PKPass(
	        {},
	        {
	            wwdr: certificates.wwdr,
	            signerCert: certificates.signerCert,
	            signerKey: certificates.signerKey,
	        },
	        {
	            ...appleJSONObj,
	            serialNumber: props.cardId,
	            organizationName: cardTemplate.business.name,
	            webServiceURL: config.applePasses.webServiceURL,
	            authenticationToken: signApplePassAuthTokens({
	                cardId: props.cardId,
	                cardType: appleJSONObj.type,
	            }),
	
	            // to work with passbook
	            semantics: {},
	            userInfo: {},
	            sharingProhibited: true,
	        },
	    );
	
	    pass.type = appleJSONObj.type;
	
	    // Add header, primary, secondary, auxiliary, and back fields
	    if (appleJSONObj.headerFields) appleJSONObj.headerFields.forEach((field: any) => pass.headerFields.push(field));
	    if (appleJSONObj.primaryFields) appleJSONObj.primaryFields.forEach((field: any) => pass.primaryFields.push(field));
	    if (appleJSONObj.secondaryFields)
	        appleJSONObj.secondaryFields.forEach((field: any) => pass.secondaryFields.push(field));
	    if (appleJSONObj.auxiliaryFields)
	        appleJSONObj.auxiliaryFields.forEach((field: any) => pass.auxiliaryFields.push(field));
	    if (appleJSONObj.backFields) appleJSONObj.backFields.forEach((field: any) => pass.backFields.push(field));
	
	    // add barcode
	    pass.setBarcodes({
	        message: props.cardId,
	        format: appleJSONObj.barcode.format,
	    });
	
	    // add icon images
	    pass.addBuffer('icon.png', icon.Body as Buffer);
	    pass.addBuffer('icon@2x.png', icon.Body as Buffer);
	
	    // add logo images
	    pass.addBuffer('logo.png', logo.Body as Buffer);
	    pass.addBuffer('logo@2x.png', logo.Body as Buffer);
	
	    // add thumbnail image
	    if (thumbnail) {
	        pass.addBuffer('thumbnail.png', thumbnail.Body as Buffer);
	        pass.addBuffer('thumbnail@2x.png', thumbnail.Body as Buffer);
	    }
	    // add footer image
	    if (footer) {
	        pass.addBuffer('footer.png', footer.Body as Buffer);
	        pass.addBuffer('footer@2x.png', footer.Body as Buffer);
	    }
	    // add background image
	    if (background) {
	        pass.addBuffer('background.png', background.Body as Buffer);
	        pass.addBuffer('background@2x.png', background.Body as Buffer);
	    }
	
	    // add strip image
	    if (strip) {
	        let success = false;
	
	        // generate stickers if possible
	        if (cardTemplate.cardType === CardType.ITEMS_SUBSCRIPTION)
	            success = await itemsSubGenerateStickersIfPossible(
	                pass,
	                props.cardTemplateId,
	                Number(props.cardId),
	                strip.Body as Buffer,
	            );
	        else if (cardTemplate.cardType === CardType.LOYALTY)
	            success = await loyaltyGenerateStickersIfPossible(
	                pass,
	                props.cardTemplateId,
	                Number(props.cardId),
	                strip.Body as Buffer,
	            );
	
	        if (!success) {
	            pass.addBuffer('strip.png', strip.Body as Buffer);
	            pass.addBuffer('strip@2x.png', strip.Body as Buffer);
	        }
	    }
	
	    pass.setLocations();
	
	    return pass;
	}
```

modules/apple-passes/utils/index.ts:
```
	import { promises as fs, writeFileSync } from 'fs';
	import path from 'path';
	import { Card } from '../../cards/models/card.model';
	import { CardTemplate, CardType } from '../../card-templates/models/card-template.model';
	import { LoyaltyCard } from '../../cards/models/loyalty-card.model';
	import { PKPass } from 'passkit-generator';
	import { ItemsSubscriptionCardTemplate } from '../../card-templates/models/items-subscription-card-template.model';
	import sharp, { OverlayOptions, Sharp } from 'sharp';
	import { BUCKET_NAME, getFile, s3LocationToKey } from '../../aws/s3';
	import { ItemsSubscriptionCard } from '../../cards/models/items-subscription-card.model';
	
	interface Cache {
	    certificates:
	        | {
	              signerCert: Buffer | string;
	              signerKey: Buffer | string;
	              wwdr: Buffer | string;
	          }
	        | undefined;
	}
	
	const cache: Cache = {
	    certificates: undefined,
	};
	
	export async function getCertificates(): Promise<Exclude<Cache['certificates'], undefined>> {
	    if (cache.certificates) {
	        return cache.certificates;
	    }
	
	    const [signerCert, signerKey, wwdr] = await Promise.all([
	        fs.readFile(path.resolve(__dirname, '../../../certs/signerCert.pem')),
	        fs.readFile(path.resolve(__dirname, '../../../certs/signerKey.key')),
	        fs.readFile(path.resolve(__dirname, '../../../certs/wwdr.pem')),
	    ]);
	
	    cache.certificates = {
	        signerCert,
	        signerKey,
	        wwdr,
	    };
	
	    return cache.certificates;
	}
	
	/**
	 * Variables
	 * ---------
	 * {{clientName}} - client name
	 * {{points}} - loyalty points
	 * {{itemsUsed}} - items used
	 * {{itemsLeft}} - items left
	 **/
	export const populateVariables = async (str: string, cardId: number) => {
	    // get card
	    const card = (await Card.findOne({
	        where: { id: cardId },
	        include: [
	            {
	                model: CardTemplate,
	                as: 'cardTemplate',
	            },
	        ],
	    })) as Card & { cardTemplate: CardTemplate };
	
	    const cardType = card.cardTemplate.cardType;
	
	    // client name
	    str = str.replace(/{{clientName}}/g, card.clientName);
	
	    switch (cardType) {
	        case CardType.LOYALTY:
	            const loyaltyCard = await LoyaltyCard.findOne({
	                where: { id: cardId },
	            });
	
	            // replace {{points}} with loyalty points
	            str = str.replace(/{{points}}/g, loyaltyCard.points.toString());
	            break;
	
	        case CardType.ITEMS_SUBSCRIPTION:
	            const itemsSubscriptionCard = await ItemsSubscriptionCard.findOne({
	                where: { id: cardId },
	            });
	            const itemsSubscriptionCardTemplate = await ItemsSubscriptionCardTemplate.findOne({
	                where: { id: card.cardTemplate.id },
	            });
	
	            // items used
	            str = str.replace(/{{itemsUsed}}/g, (itemsSubscriptionCardTemplate.nItems - itemsSubscriptionCard.nItems).toString());
	
	            // items left
	            str = str.replace(
	                /{{itemsLeft}}/g,
	                (itemsSubscriptionCard.nItems).toString(),
	            );
	            break;
	    }
	
	    return str;
	};
	
	export const loyaltyGenerateStickersIfPossible = async (
	    pass: PKPass,
	    cardTemplateId: number,
	    cardId: number,
	    stripBuffer: Buffer,
	) => {
	    // get card template
	    const cardTemplate = await CardTemplate.findOne({
	        where: { id: cardTemplateId },
	    });
	    // return if not an items subscription card template
	    if (cardTemplate.cardType !== CardType.LOYALTY) return;
	
	    // check for stickers and stickersCount
	    if (!cardTemplate.stickers || cardTemplate.stickers?.length === 0) return;
	
	    // get card
	    const card = await Card.findOne({
	        where: { id: cardId },
	    });
	    if (!card) throw new Error('Card not found');
	
	    const stripWidth = 1125;
	    const stripHeight = 432;
	    const margin = 0.1;
	    const innerStripWidth = stripWidth * (1 - margin * 2);
	    const innerStripHeight = stripHeight * (1 - margin * 2);
	
	    const stickersPerRow = 1;
	    const numberOfRows = 1;
	
	    const stickerSize = Math.min(innerStripWidth / stickersPerRow, innerStripHeight / numberOfRows);
	    const stickerCellWidth = innerStripWidth / stickersPerRow;
	    const stickerVerticalMargin = 5;
	
	    // get sticker buffer
	    const stickerBuffer = await getFile(
	        cardTemplate.stickers[0].imageUrl.includes(`https://${BUCKET_NAME}.s3`)
	            ? s3LocationToKey(cardTemplate.stickers[0].imageUrl)
	            : `card-templates/${cardTemplateId}/stickers/${cardTemplate.stickers[0].title}.${cardTemplate.stickers[0].imageType}`,
	    )
	        .then((out) => out.Body)
	        .catch((err) => {
	            console.error(err);
	        });
	
	    const highlightedSticker = await handleStickerSharpToBuffer(sharp(stickerBuffer), stickerSize);
	    const bwSticker = await handleStickerSharpToBuffer(sharp(stickerBuffer).grayscale(), stickerSize);
	
	    let stickerToUse: Buffer = (await card.loyaltyCanScan()) ? bwSticker : highlightedSticker;
	
	    // composite stickers on the strip
	    const compositeOperations: OverlayOptions[] = await compositeStickersOnStrip(
	        numberOfRows,
	        stickersPerRow,
	        1,
	        [stickerToUse],
	        stickerToUse,
	        stripHeight,
	        stickerSize,
	        stickerVerticalMargin,
	        margin,
	        stickerCellWidth,
	        stripWidth,
	    );
	
	    // render stickers on the strip
	    await rednerSticckersOnStrip(pass, stripBuffer, stripWidth, stripHeight, compositeOperations);
	
	    return true;
	};
	
	export const itemsSubGenerateStickersIfPossible = async (
	    pass: PKPass,
	    cardTemplateId: number,
	    cardId: number,
	    stripBuffer: Buffer,
	) => {
	    // get card template
	    const cardTemplate = await CardTemplate.findOne({
	        where: { id: cardTemplateId },
	    });
	    // return if not an items subscription card template
	    if (cardTemplate.cardType !== CardType.ITEMS_SUBSCRIPTION) return;
	
	    // check for stickers and stickersCount
	    if (!cardTemplate.stickers || !cardTemplate.stickersCount) return;
	
	    // get card
	    const card = await Card.findOne({
	        where: { id: cardId },
	    });
	    if (!card) throw new Error('Card not found');
	
	    const chosenStickers = card.chosenStickers || [];
	
	    const stickersCount = cardTemplate.stickersCount;
	
	    const stripWidth = 1125;
	    const stripHeight = 432;
	    const margin = 0.1;
	    const innerStripWidth = stripWidth * (1 - margin * 2);
	    const innerStripHeight = stripHeight * (1 - margin * 2);
	
	    // formula to calculate the MAX_STICKERS_PER_ROW relative to the number of stickers in the strip
	    const MAX_STICKERS_PER_ROW = Math.max(Math.ceil(Math.sqrt(stickersCount)), 5);
	
	    const stickersPerRow = Math.min(stickersCount, MAX_STICKERS_PER_ROW);
	    const numberOfRows = Math.ceil(stickersCount / stickersPerRow);
	
	    const stickerSize = Math.min(innerStripWidth / stickersPerRow, innerStripHeight / numberOfRows);
	    const stickerCellWidth = innerStripWidth / stickersPerRow;
	    const stickerVerticalMargin = 5;
	
	    // find choosen stickers
	    const choosenStickerBuffers = await Promise.all(
	        chosenStickers.map(
	            async (sticker) =>
	                await handleStickerSharpToBuffer(
	                    sharp(
	                        await getFile(
	                            sticker.imageUrl.includes(`https://${BUCKET_NAME}.s3`)
	                                ? s3LocationToKey(sticker.imageUrl)
	                                : `card-templates/${cardTemplateId}/stickers/${sticker.title}.${sticker.imageType}`,
	                        )
	                            .then((out) => out.Body)
	                            .catch((err) => {
	                                console.error(err);
	                            }),
	                    ),
	                    stickerSize,
	                ),
	        ),
	    );
	
	    // generate placeholder sticker
	    const stickerPlaceholderBuffer = await handleStickerSharpToBuffer(
	        sharp({
	            create: {
	                width: Math.round(stickerSize),
	                height: Math.round(stickerSize),
	                channels: 4,
	                background: { r: 0, g: 0, b: 0, alpha: 0.5 },
	            },
	        }),
	        stickerSize,
	    );
	
	    // composite stickers on the strip
	    const compositeOperations: OverlayOptions[] = await compositeStickersOnStrip(
	        numberOfRows,
	        stickersPerRow,
	        stickersCount,
	        choosenStickerBuffers,
	        stickerPlaceholderBuffer,
	        stripHeight,
	        stickerSize,
	        stickerVerticalMargin,
	        margin,
	        stickerCellWidth,
	        stripWidth,
	    );
	
	    // render stickers on the strip
	    await rednerSticckersOnStrip(pass, stripBuffer, stripWidth, stripHeight, compositeOperations);
	
	    return true;
	};
	
	export const compositeStickersOnStrip = async (
	    numberOfRows: number,
	    stickersPerRow: number,
	    stickersCount: number,
	    choosenStickerBuffers: Buffer[],
	    stickerPlaceholderBuffer: Buffer,
	    stripHeight: number,
	    stickerSize: number,
	    stickerVerticalMargin: number,
	    margin: number,
	    stickerCellWidth: number,
	    stripWidth: number,
	) => {
	    // composite stickers on the strip
	    const compositeOperations: OverlayOptions[] = [];
	    for (let row = 0; row < numberOfRows; row++) {
	        for (let column = 0; column < stickersPerRow; column++) {
	            const index = row * stickersPerRow + column;
	
	            if (index >= stickersCount) break;
	
	            compositeOperations.push({
	                input: choosenStickerBuffers[index] || stickerPlaceholderBuffer,
	                top:
	                    numberOfRows === 1
	                        ? Math.round((stripHeight - stickerSize) / 2)
	                        : Math.round(
	                              row * (stickerSize + (row !== 0 ? stickerVerticalMargin : 0)) +
	                                  stripHeight * margin -
	                                  stickerVerticalMargin * (numberOfRows - 2),
	                          ),
	                left: Math.round(
	                    column * stickerCellWidth + stripWidth * margin + stickerCellWidth / 2 - stickerSize / 2,
	                ),
	            });
	        }
	    }
	
	    return compositeOperations;
	};
	
	const rednerSticckersOnStrip = (
	    pass: PKPass,
	    stripBuffer: Buffer,
	    stripWidth: number,
	    stripHeight: number,
	    compositeOperations: OverlayOptions[],
	) => {
	    // render stickers on the strip
	    return sharp(stripBuffer)
	        .resize(Math.round(stripWidth), Math.round(stripHeight))
	        .composite(compositeOperations)
	        .toBuffer()
	        .then((buffer) => {
	            pass.addBuffer('strip.png', buffer);
	            pass.addBuffer('strip@2x.png', buffer);
	
	            // write to file
	            // writeFileSync('strip.png', buffer);
	        })
	        .catch((err) => {
	            console.error(err);
	            throw err;
	        });
	};
	
	const handleStickerSharpToBuffer = async (x: Sharp, stickerSize: number) => {
	    return x
	        .resize(Math.round(stickerSize), Math.round(stickerSize))
	        .png()
	        .composite([
	            {
	                input: Buffer.from(
	                    `<svg><rect x="0" y="0" width="${stickerSize}" height="${stickerSize}" rx="${
	                        stickerSize / 2
	                    }" ry="${stickerSize / 2}" /></svg>`,
	                ),
	                blend: 'dest-in',
	            },
	        ])
	        .toBuffer();
	};
```

modules/auth/controllers/Auth.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import { validateDto } from '../../../helpers';
	import { LoginDto } from '../dto/login';
	import { login } from '../services';
	import { HttpError } from '../../../common';
	
	export const AuthController = {
	    login: (req: Request, res: Response, next: NextFunction) => {
	        const loginDto = validateDto(LoginDto, req.body);
	        login(loginDto)
	            .then((out) => res.json(out))
	            .catch((err) => {
	                next(new HttpError(401, err.message));
	            });
	    },
	};
```

modules/auth/dto/login.ts:
```
	import { IsEmail, IsNotEmpty, IsString } from 'class-validator';
	
	export class LoginDto {
	    @IsNotEmpty()
	    @IsEmail()
	    email: string;
	
	    @IsNotEmpty()
	    @IsString()
	    password: string;
	}
```

modules/auth/services/index.ts:
```
	import { LoginDto } from '../dto/login';
	import bcrypt from 'bcrypt';
	import { signJWT } from './jwt';
	import { User } from '../../users/models/user.model';
	import { Business } from '../../businesses/models/business.model';
	import { Branch } from '../../branches/models/branch.model';
	
	export const login = async (loginDto: LoginDto) => {
	    const { email, password } = loginDto;
	
	    const user = await User.findOne({
	        where: {
	            email,
	        },
	        include: [
	            {
	                model: Business,
	                as: 'businesses',
	            },
	            {
	                model: Branch,
	                as: 'employedAt',
	            },
	        ],
	    });
	    if (!user) throw new Error('Invalid credentials');
	
	    const isPasswordValid = await bcrypt.compare(password, user.password);
	    if (!isPasswordValid) throw new Error('Invalid credentials');
	
	    return {
	        ...user.toJSON(),
	        token: signJWT(user as User & { businesses: Business[]; employedAt: Branch[] }),
	    };
	};
```

modules/auth/services/jwt.ts:
```
	import { sign, verify } from 'jsonwebtoken';
	import { IJWTPayload } from '../../../common/interfaces/jwt-payload';
	import { User } from '../../users/models/user.model';
	import config from '../../../config';
	
	export const signJWT = (user: User) => {
	    const payload: IJWTPayload = {
	        userId: user.id,
	        email: user.email,
	        firstName: user.firstName,
	        lastName: user.lastName,
	        businesses: user.businesses.map((business) => business.id),
	        roles: user.roles,
	        employedAt: user.employedAt.map((branch) => branch.id),
	    };
	    return sign(payload, config.JWT.secret, { expiresIn: config.JWT.expiresIn });
	};
	
	export const signApplePassAuthTokens = ({ cardId, cardType }) => {
	    const payload = {
	        cardId,
	        cardType,
	    };
	    return sign(payload, config.JWT.secret);
	};
	
	export const verifyJWT = (token: string): IJWTPayload => {
	    // @ts-ignore
	    return verify(token, config.JWT.secret);
	};
```

modules/aws/index.ts:
```
	import * as AWS from 'aws-sdk';
	import config from '../../config';
	
	AWS.config.update({
	    secretAccessKey: config.aws.secretAccessKey,
	    accessKeyId: config.aws.accessKeyId,
	    region: config.aws.region,
	    signatureVersion: 'v4', //API version
	});
	
	// S3
	export const s3 = new AWS.S3({ signatureVersion: 'v4' });
```

modules/aws/s3.ts:
```
	import { GetObjectOutput, ManagedUpload } from 'aws-sdk/clients/s3';
	import { s3 } from '.';
	import config from '../../config';
	
	export const BUCKET_NAME = config.aws.s3.bucketName;
	
	export const uploadFile = async (
	    file: {
	        name: string;
	        data: Buffer;
	        contentType?: string;
	        ContentDisposition?: string;
	    },
	    folder: string,
	): Promise<ManagedUpload.SendData> => {
	    const params = {
	        Bucket: BUCKET_NAME,
	        Key: `${folder}/${file.name}`,
	        Body: file.data,
	        ContentType: file.contentType || 'application/octet-stream',
	        ContentDisposition: file.ContentDisposition || undefined,
	    };
	    return await s3.upload(params).promise();
	};
	
	export const deleteFile = async (key: string): Promise<void> => {
	    const params = {
	        Bucket: BUCKET_NAME,
	        Key: key,
	    };
	    await s3.deleteObject(params).promise();
	};
	
	export const getFile = async (key: string) => {
	    if (!key) return null;
	
	    const params = {
	        Bucket: BUCKET_NAME,
	        Key: key,
	    };
	    return await s3
	        .getObject(params)
	        .promise()
	        .catch((err) => {
	            console.log(err);
	            console.log('key', key);
	            return null;
	        });
	};
	
	export const deleteFolder = async (dir) => {
	    const listParams = {
	        Bucket: BUCKET_NAME,
	        Prefix: dir,
	    };
	
	    const listedObjects = await s3.listObjectsV2(listParams).promise();
	
	    if (listedObjects.Contents.length === 0) return;
	
	    const deleteParams = {
	        Bucket: BUCKET_NAME,
	        Delete: { Objects: [] },
	    };
	
	    listedObjects.Contents.forEach(({ Key }) => {
	        deleteParams.Delete.Objects.push({ Key });
	    });
	
	    await s3.deleteObjects(deleteParams).promise();
	
	    if (listedObjects.IsTruncated) await deleteFile(dir);
	};
	
	export const s3LocationToKey = (location: string) => {
	    if (!location) return null;
	    const key = location.split('amazonaws.com/')[1].replace('+', ' ');
	    return key;
	};
```

modules/branches/controllers/Branches.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import * as branchServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { CreateBranchDto } from '../dto/create-branch';
	import { UpdateBranchDto } from '../dto/update-branch';
	
	export const BranchController: ICRUDController = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const body: CreateBranchDto = req.body;
	        branchServices
	            .createBranch(body, req)
	            .then((branch) => res.status(201).json(branch))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const branchId = Number(req.params.id);
	
	        branchServices
	            .findOneBranchById(branchId)
	            .then((branch) => res.json(branch))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	
	        branchServices
	            .findAllBranches({ limit, offset, req })
	            .then((branch) => res.json(branch))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: Request, res: Response, next: NextFunction): void {
	        const branchId = Number(req.params.id);
	        const body: UpdateBranchDto = req.body;
	
	        branchServices
	            .updateBranchById(branchId, body)
	            .then((branch) => res.json(branch))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const branchId = Number(req.params.id);
	
	        branchServices
	            .deleteBranchById(branchId)
	            .then((branch) => res.json(branch))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	};
```

modules/branches/dto/create-branch.ts:
```
	import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';
	
	export class CreateBranchDto {
	    @IsNotEmpty()
	    @IsString()
	    name: string;
	
	    @IsNotEmpty()
	    @IsString()
	    address: string;
	
	    @IsOptional()
	    @IsString()
	    googleMapsLocation?: string;
	
	    @IsNotEmpty()
	    @IsNumber()
	    businessId: Number;
	}
```

modules/branches/dto/update-branch.ts:
```
	import { CreateBranchDto } from './create-branch';
	import { PartialType } from '@nestjs/mapped-types';
	
	export class UpdateBranchDto extends PartialType(CreateBranchDto) {}
```

modules/branches/models/branch.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Business } from '../../businesses/models/business.model';
	import { Card } from '../../cards/models/card.model';
	import { User } from '../../users/models/user.model';
	
	export class Branch extends Model {
	    public declare id: number;
	    public name!: string;
	    public address!: string;
	    public businessId!: number;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    Branch.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            name: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            address: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            googleMapsLocation: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            businessId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'branches',
	        },
	    );
	
	export const associate = () => {
	    // Branch | Business
	    Branch.belongsTo(Business, {
	        foreignKey: 'businessId',
	        as: 'business',
	    });
	
	    // User | Branch
	    Branch.belongsToMany(User, {
	        through: 'userBranches',
	        as: 'employees',
	        foreignKey: 'branchId',
	    });
	};
```

modules/branches/services/index.ts:
```
	import { Op } from 'sequelize';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { Branch } from '../models/branch.model';
	import { CreateBranchDto } from '../dto/create-branch';
	import { UpdateBranchDto } from '../dto/update-branch';
	
	export const createBranch = (createbranchDto: CreateBranchDto, req: RequestMod): Promise<Branch> => {
	    const { businessId } = createbranchDto;
	
	    // check if the business exists in the user's businesses
	    const business = req.user.businesses.find((business) => business.id === businessId);
	    if (!business) throw new HttpError(403, 'You do not own this business');
	
	    const user = new Branch({ ...createbranchDto, businessId });
	    return user.save();
	};
	
	// only select users who share a branch with the logged in user
	export const findAllBranches = async ({
	    limit = 10,
	    offset = 0,
	    req,
	}: {
	    limit: number;
	    offset: number;
	    req: RequestMod;
	}) => {
	    return Branch.findAndCountAll({
	        where: {
	            businessId: {
	                [Op.in]: req.user.businesses.map((business) => business.id),
	            },
	        },
	        limit,
	        offset,
	    });
	};
	
	export const findOneBranchById = (branchId: number): Promise<Branch> => {
	    return Branch.findOne({
	        where: {
	            id: branchId,
	        },
	    });
	};
	
	export const updateBranchById = async (branchId: number, updatebranchDto: UpdateBranchDto): Promise<Branch> => {
	    const branch = await findOneBranchById(branchId);
	    if (!branch) throw new HttpError(404, 'branch not found');
	
	    return branch.update(updatebranchDto);
	};
	
	export const deleteBranchById = async (branchId: number) => {
	    const branch = await findOneBranchById(branchId);
	    if (!branch) throw new HttpError(404, 'branch not found');
	
	    return branch.destroy().then(() => ({ message: 'branch deleted successfully' }));
	};
```

modules/businesses/controllers/Business.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import * as businessServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { CreateBusinessDto } from '../dto/create-business';
	import { UpdateBusinessDto } from '../dto/update-business';
	
	export const BusinessController: ICRUDController = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const body: CreateBusinessDto = req.body;
	        businessServices
	            .createBusiness(body, req)
	            .then((business) => res.status(201).json(business))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const businessId = Number(req.params.id);
	
	        businessServices
	            .findOneBusinessById(businessId)
	            .then((business) => res.json(business))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	
	        businessServices
	            .findAllBusinesses({ limit, offset, req })
	            .then((business) => res.json(business))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: Request, res: Response, next: NextFunction): void {
	        const businessId = Number(req.params.id);
	        const body: UpdateBusinessDto = req.body;
	
	        businessServices
	            .updateBusinessById(businessId, body)
	            .then((business) => res.json(business))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const businessId = Number(req.params.id);
	
	        businessServices
	            .deleteBusinessById(businessId)
	            .then((business) => res.json(business))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	};
```

modules/businesses/controllers/menu.ts:
```
	import { NextFunction, Response } from 'express';
	import * as menuServices from '../services/menu.services';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { MenuItemDto } from '../dto/create-menu';
	import { handleControllerServiceError } from '../../../helpers';
	
	export const MenuController = {
	    createMenu: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const businessId = Number(req.params.businessId);
	        menuServices
	            .createMenu(businessId, req.body)
	            .then((business) => res.status(201).json(business))
	            .catch(handleControllerServiceError(next));
	    },
	
	    getMenu: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const businessId = Number(req.params.businessId);
	        menuServices
	            .getMenu(businessId)
	            .then((menu) => res.status(200).json(menu))
	            .catch(handleControllerServiceError(next));
	    },
	
	    updateMenuItem: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const menuItemId = Number(req.params.menuItemId);
	        const menuItemDto: MenuItemDto = req.body;
	        menuServices
	            .updateMenuItem(menuItemId, menuItemDto)
	            .then((menu) => res.status(200).json(menu))
	            .catch(handleControllerServiceError(next));
	    },
	
	    deleteMenuItem: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const menuItemId = Number(req.params.menuItemId);
	        menuServices
	            .deleteMenuItem(menuItemId)
	            .then((menu) => res.status(200).json(menu))
	            .catch(handleControllerServiceError(next));
	    },
	
	    deleteMenu: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const businessId = Number(req.params.businessId);
	        menuServices
	            .deleteMenu(businessId)
	            .then((menu) => res.status(200).json(menu))
	            .catch(handleControllerServiceError(next));
	    },
	
	    addMenuItems: async (req: RequestMod, res: Response, next: NextFunction) => {
	        const businessId = Number(req.params.businessId);
	        const { menuItems } = req.body;
	        menuServices
	            .addMenuItems(businessId, menuItems)
	            .then((menu) => res.status(201).json(menu))
	            .catch(handleControllerServiceError(next));
	    },
	};
```

modules/businesses/dto/create-business.ts:
```
	import { IsNotEmpty, IsString } from 'class-validator';
	
	export class CreateBusinessDto {
	    @IsNotEmpty()
	    @IsString()
	    name: string;
	}
```

modules/businesses/dto/create-menu.ts:
```
	import { Type } from 'class-transformer';
	import { IsArray, IsNotEmpty, IsNumber, IsString, ValidateNested } from 'class-validator';
	
	export class MenuItemDto {
	    // name
	    @IsNotEmpty()
	    @IsString()
	    itemName: string;
	
	    // description
	    @IsString()
	    itemDescription: string;
	
	    // price
	    @IsNotEmpty()
	    @IsNumber()
	    itemPrice: string;
	}
	
	export class CreateMenuDto {
	    // menu items
	    @IsArray()
	    @ValidateNested({ each: true })
	    @Type(() => MenuItemDto)
	    menuItems: MenuItemDto[];
	}
```

modules/businesses/dto/update-business.ts:
```
	import { PartialType } from '@nestjs/mapped-types';
	import { CreateBusinessDto } from './create-business';
	
	export class UpdateBusinessDto extends PartialType(CreateBusinessDto) {}
```

modules/businesses/models/activity.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Business } from './business.model';
	import { Card } from '../../cards/models/card.model';
	import { User } from '../../users/models/user.model';
	import { LoyaltyGift } from '../../card-templates/models/loyalty-gift.model';
	import { Event } from '../../events/models/event.model';
	
	export enum ActivityType {
	    CREATE_CARD = 'CreateCard',
	    UPDATE_CARD = 'UpdateCard',
	    SCAN_CARD = 'ScanCard',
	
	    // Loyalty
	    LOYALTY_ADD_POINTS = 'LoyaltyAddPoints',
	    LOYALTY_UPDATE_POINTS = 'LoyaltyUpdatePoints',
	
	    // Loyalty Gift
	    LOYALTY_GIFT_CREATE = 'LoyaltyGiftCreate',
	    LOYALTY_GIFT_UPDATE = 'LoyaltyGiftUpdate',
	    LOYALTY_GIFT_DELETE = 'LoyaltyGiftDelete',
	    LOYALTY_GIFT_REDEEM = 'LoyaltyGiftRedeem',
	
	    // Items Subscriptions
	    ITEM_SUBSCRIPTION_USE = 'ItemSubscriptionUse',
	}
	
	export class Activity extends Model {
	    public declare id: number;
	    public businessId!: number;
	    public message?: string;
	    public types!: [ActivityType];
	    public userId?: number;
	    public relatedId?: number;
	    public relatedType?: 'card' | 'loyaltyGift' | 'event';
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    Activity.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            businessId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            message: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            types: {
	                type: DataTypes.ARRAY(DataTypes.STRING),
	                allowNull: false,
	            },
	            userId: {
	                type: DataTypes.INTEGER,
	                allowNull: true,
	            },
	            relatedId: {
	                type: DataTypes.INTEGER,
	                allowNull: true,
	            },
	            relatedType: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'activities',
	        },
	    );
	
	export const associate = () => {
	    Activity.belongsTo(Business, {
	        foreignKey: 'businessId',
	        as: 'business',
	    });
	
	    Activity.belongsTo(User, {
	        foreignKey: 'userId',
	        as: 'user',
	    });
	
	    // polymorphic association
	    Activity.belongsTo(Card, {
	        foreignKey: 'relatedId',
	        constraints: false,
	        as: 'card',
	    });
	
	    Activity.belongsTo(LoyaltyGift, {
	        foreignKey: 'relatedId',
	        constraints: false,
	        as: 'loyaltyGift',
	    });
	    
	    Activity.belongsTo(Event, {
	        foreignKey: 'relatedId',
	        constraints: false,
	        as: 'event',
	    });
	};
```

modules/businesses/models/business.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { User } from '../../users/models/user.model';
	import { Branch } from '../../branches/models/branch.model';
	import { CardTemplate } from '../../card-templates/models/card-template.model';
	import { Activity } from './activity.model';
	import { Event } from '../../events/models/event.model';
	
	export class Business extends Model {
	    public declare id: number;
	    public name!: string;
	    public ownerId!: number;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    Business.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            name: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            ownerId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'businesses',
	        },
	    );
	
	export const associate = () => {
	    // User | Business
	    Business.belongsTo(User, {
	        foreignKey: 'ownerId',
	        as: 'owner',
	    });
	
	    // Business | Branch
	    Business.hasMany(Branch, {
	        foreignKey: 'businessId',
	        as: 'branches',
	    });
	
	    // Business | Card Template
	    Business.hasMany(CardTemplate, {
	        foreignKey: 'businessId',
	        as: 'cardTemplates',
	    });
	
	    // Business | Menu
	    Business.hasMany(CardTemplate, {
	        foreignKey: 'businessId',
	        as: 'menu',
	        onDelete: 'CASCADE',
	    });
	
	    // Business | Activity
	    Business.hasMany(Activity, {
	        foreignKey: 'businessId',
	        as: 'activities',
	    });
	
	    // Business | Event
	    Business.hasMany(Event, {
	        foreignKey: 'businessId',
	        as: 'events',
	    });
	};
```

modules/businesses/models/menu/menu-item.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Menu } from './menu.model';
	
	export class MenuItem extends Model {
	    public declare id: number;
	    public itemName!: string;
	    public itemDescription!: string;
	    public itemPrice!: number;
	    public declare menuId: number;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    MenuItem.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            itemName: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            itemDescription: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            itemPrice: {
	                type: DataTypes.DOUBLE,
	                allowNull: false,
	            },
	            menuId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'menu_items',
	        },
	    );
	
	export const associate = () => {
	    MenuItem.belongsTo(Menu, {
	        foreignKey: 'menuId',
	        as: 'menu',
	    });
	};
```

modules/businesses/models/menu/menu.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Business } from '../business.model';
	import { MenuItem } from './menu-item.model';
	
	export class Menu extends Model {
	    public declare id: number;
	    public businessId!: number;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    Menu.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            businessId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'menus',
	        },
	    );
	
	export const associate = () => {
	    // Business | Menu
	    Menu.belongsTo(Business, {
	        foreignKey: 'businessId',
	        as: 'business',
	    });
	
	    // Menu | Menu Item
	    Menu.hasMany(MenuItem, {
	        foreignKey: 'menuId',
	        as: 'menuItems',
	        onDelete: 'CASCADE',
	    });
	};
```

modules/businesses/services/index.ts:
```
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { Branch } from '../../branches/models/branch.model';
	import { Business } from '../models/business.model';
	import { CreateBusinessDto } from '../dto/create-business';
	import { UpdateBusinessDto } from '../dto/update-business';
	
	export const createBusiness = (createBusinessDto: CreateBusinessDto, req: RequestMod): Promise<Business> => {
	    const user = new Business({ ...createBusinessDto, ownerId: req.user.id });
	    return user.save();
	};
	
	// only select users who share a business with the logged in user
	export const findAllBusinesses = async ({
	    limit = 10,
	    offset = 0,
	    req,
	}: {
	    limit: number;
	    offset: number;
	    req: RequestMod;
	}) => {
	    return Business.findAndCountAll({
	        where: {
	            ownerId: req.user.id,
	        },
	        include: {
	            model: Branch,
	            as: 'branches',
	        },
	        limit,
	        offset,
	    });
	};
	
	export const findOneBusinessById = (businessId: number): Promise<Business> => {
	    return Business.findOne({
	        where: {
	            id: businessId,
	        },
	        include: [
	            {
	                model: Branch,
	                as: 'branches',
	            },
	        ],
	    });
	};
	
	export const updateBusinessById = async (
	    businessId: number,
	    updateBusinessDto: UpdateBusinessDto,
	): Promise<Business> => {
	    const business = await findOneBusinessById(businessId);
	    if (!business) throw new HttpError(404, 'Business not found');
	
	    return business.update(updateBusinessDto);
	};
	
	export const deleteBusinessById = async (businessId: number) => {
	    const business = await findOneBusinessById(businessId);
	    if (!business) throw new HttpError(404, 'Business not found');
	
	    return business.destroy().then(() => ({ message: 'Business deleted successfully' }));
	};
```

modules/businesses/services/menu.services.ts:
```
	import { HttpError } from '../../../common';
	import { CreateMenuDto, MenuItemDto } from '../dto/create-menu';
	import { MenuItem } from '../models/menu/menu-item.model';
	import { Menu } from '../models/menu/menu.model';
	
	// create menu
	export const createMenu = async (businessId: number, createMenuDto: CreateMenuDto) => {
	    // check if menu exists
	    const menuExists = await Menu.findOne({
	        where: {
	            businessId,
	        },
	    });
	    if (menuExists) throw new HttpError(400, 'A menu already exists');
	
	    // create menu
	    const menu = await new Menu({
	        businessId,
	    }).save();
	
	    // create menu items
	    const menu_items = await MenuItem.bulkCreate(
	        createMenuDto.menuItems.map((item: MenuItemDto) => ({
	            ...item,
	            menuId: menu.id,
	        })),
	    );
	
	    // return menu
	    return {
	        ...menu.toJSON(),
	        menu_items: menu_items.map((item) => item.toJSON()),
	    };
	};
	
	// get menu
	export const getMenu = async (businessId: number) => {
	    // get menu
	    const menu = await Menu.findOne({
	        where: {
	            businessId,
	        },
	        include: [
	            {
	                model: MenuItem,
	                as: 'menuItems',
	            },
	        ],
	    });
	
	    // return menu
	    return menu;
	};
	
	// update menu item
	export const updateMenuItem = async (menuItemId: number, updateMenuItemDto: MenuItemDto) => {
	    // update menu item
	    const menuItem = await MenuItem.update(
	        {
	            ...updateMenuItemDto,
	        },
	        {
	            where: {
	                id: menuItemId,
	            },
	        },
	    );
	
	    // return menu item
	    return menuItem;
	};
	
	// delete menu item
	export const deleteMenuItem = async (menuItemId: number) => {
	    // delete menu item
	    return await MenuItem.destroy({
	        where: {
	            id: menuItemId,
	        },
	    });
	};
	
	// delete menu
	export const deleteMenu = async (businessId: number) => {
	    // delete menu
	    return await Menu.destroy({
	        where: {
	            businessId,
	        },
	    });
	};
	
	// add menu items
	export const addMenuItems = async (businessId: number, menuItems: MenuItemDto[]) => {
	    // get menu
	    const menu = await Menu.findOne({
	        where: {
	            businessId,
	        },
	    });
	
	    // create menu items
	    const menu_items = await MenuItem.bulkCreate(
	        menuItems.map((item: MenuItemDto) => ({
	            ...item,
	            menuId: menu.id,
	        })),
	    );
	
	    // return menu items
	    return menu_items;
	};
```

modules/card-templates/controllers/CardTemplate.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import * as cardTemplateServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { CreateCardTemplateDto } from '../dto/create-card-template';
	import { UpdateCardTemplateDto } from '../dto/update-card-template';
	import { CreateLoyaltyGiftDto } from '../dto/create-loyalty-gift.dto';
	
	export const CardTemplateController: ICRUDController & {
	    addGiftToLoyaltyCardTemplate: (req: Request, res: Response, next: NextFunction) => void;
	    updateGiftInLoyaltyCardTemplate: (req: Request, res: Response, next: NextFunction) => void;
	    deleteGiftFromLoyaltyCardTemplate: (req: Request, res: Response, next: NextFunction) => void;
	} = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const businessId = Number(req.params.businessId);
	        const body: CreateCardTemplateDto = req.body;
	        cardTemplateServices
	            .createCardTemplate(body, businessId, req)
	            .then((cardTemplate) => res.status(201).json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	        const businessId = Number(req.params.businessId);
	
	        cardTemplateServices
	            .findOneCardTemplateById(cardTemplateId, businessId)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	        const businessId = Number(req.params.businessId);
	
	        cardTemplateServices
	            .findAllCardTemplates({ limit, offset, req, businessId })
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: Request, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	        const businessId = Number(req.params.businessId);
	        const body: CreateCardTemplateDto = req.body;
	
	        cardTemplateServices
	            .updateCardTemplateById(cardTemplateId, businessId, body)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	
	        cardTemplateServices
	            .deleteCardTemplateById(cardTemplateId)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    addGiftToLoyaltyCardTemplate: function (req: Request, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	        const body: CreateLoyaltyGiftDto = req.body;
	
	        cardTemplateServices
	            .addGiftToLoyaltyCardTemplate(cardTemplateId, body)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    updateGiftInLoyaltyCardTemplate: function (req: Request, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	        const giftId = Number(req.params.giftId);
	        const body: CreateLoyaltyGiftDto = req.body;
	
	        cardTemplateServices
	            .updateGiftInLoyaltyCardTemplate(cardTemplateId, giftId, body)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    deleteGiftFromLoyaltyCardTemplate: function (req: Request, res: Response, next: NextFunction): void {
	        const cardTemplateId = Number(req.params.id);
	        const giftId = Number(req.params.giftId);
	
	        cardTemplateServices
	            .deleteGiftFromLoyaltyCardTemplate(cardTemplateId, giftId)
	            .then((cardTemplate) => res.json(cardTemplate))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	};
```

modules/card-templates/dto/create-card-template.ts:
```
	import {
	    ArrayMinSize,
	    ArrayNotEmpty,
	    IsArray,
	    IsDateString,
	    IsEnum,
	    IsIn,
	    IsNotEmpty,
	    IsNotEmptyObject,
	    IsNumber,
	    IsObject,
	    IsOptional,
	    IsString,
	    IsUrl,
	    Length,
	    Matches,
	    Min,
	    MinLength,
	    ValidateIf,
	    ValidateNested,
	} from 'class-validator';
	import { CardType } from '../models/card-template.model';
	import { CreateLoyaltyGiftDto } from './create-loyalty-gift.dto';
	import { Type } from 'class-transformer';
	import { SeatType } from '../../events/models/event.model';
	import { EventTicketType } from '../models/event-ticket-template.model';
	
	export enum CardDesignType {
	    BoardingPass = 'boardingPass',
	    Coupon = 'coupon',
	    EventTicket = 'eventTicket',
	    Generic = 'generic',
	    StoreCard = 'storeCard',
	}
	
	export enum StickerImageType {
	    PNG = 'png',
	    JPG = 'jpg',
	}
	
	export class StickerDto {
	    // imageUrl
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    imageUrl: string;
	
	    // title
	    @IsNotEmpty()
	    @IsString()
	    title: string;
	
	    // imageType
	    @IsNotEmpty()
	    @IsString()
	    @IsEnum(StickerImageType)
	    imageType: StickerImageType;
	}
	
	export class CreateCardTemplateDto {
	    // name
	    @IsNotEmpty()
	    @IsString()
	    name: string;
	
	    // cardType
	    @IsNotEmpty()
	    @IsString()
	    @IsEnum(CardType)
	    cardType: CardType;
	
	    // logoText
	    @IsNotEmpty()
	    @IsString()
	    logoText: string;
	
	    // designType
	    @IsNotEmpty()
	    @IsString()
	    @IsEnum(CardDesignType)
	    designType: CardDesignType;
	
	    // logoUrl | on all card types
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    logoUrl: string;
	
	    // iconUrl | on all card types
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    iconUrl: string;
	
	    // thumbnailUrl | on generic and event ticket card types
	    @ValidateIf((o) => [CardDesignType.Generic, CardDesignType.EventTicket].includes(o.designType))
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    @IsOptional()
	    thumbnailUrl?: string;
	
	    // footerUrl | on boarding pass card type
	    @ValidateIf((o) => o.cardType === CardDesignType.BoardingPass)
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    footerUrl: string;
	
	    // stripUrl | on coupon, event ticket and store card card types
	    @ValidateIf((o) =>
	        [CardDesignType.Coupon, CardDesignType.EventTicket, CardDesignType.StoreCard].includes(o.designType),
	    )
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    stripUrl: string;
	
	    // backgroundUrl | on event ticket card type
	    @ValidateIf((o) => o.cardType === CardDesignType.EventTicket)
	    @IsNotEmpty()
	    @IsString()
	    @IsUrl()
	    @Matches(/https:\/\/zajil-bucket.s3.me-south-1.amazonaws.com/)
	    backgroundUrl: string;
	
	    // cardProps
	    @IsNotEmpty()
	    @IsObject()
	    cardProps: object;
	
	    // qrCodeFormat
	    @IsOptional()
	    @IsString()
	    @IsIn(['PKBarcodeFormatQR', 'PKBarcodeFormatPDF417', 'PKBarcodeFormatAztec', 'PKBarcodeFormatCode128'])
	    qrCodeFormat?: string;
	
	    /*
	     * Items Subscription Card Template Validation
	     * */
	
	    // maxDailyUsage
	    @ValidateIf((o) => o.cardType === CardType.ITEMS_SUBSCRIPTION)
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    maxDailyUsage: number;
	
	    // subscriptionDurationDays
	    @ValidateIf((o) => o.cardType === CardType.ITEMS_SUBSCRIPTION)
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    subscriptionDurationDays: number;
	
	    // nItems
	    @ValidateIf((o) => o.cardType === CardType.ITEMS_SUBSCRIPTION)
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(0)
	    nItems: number;
	
	    // stickers | on items subscription card type if there is a stripe image and there is noStickers
	    @ValidateIf(
	        (o) => [CardType.ITEMS_SUBSCRIPTION, CardType.LOYALTY].includes(o.cardType) && o.stripUrl && o.stickersCount,
	    )
	    @IsArray()
	    @ValidateNested({ each: true })
	    @Type(() => StickerDto)
	    stickers: StickerDto[];
	
	    // noStickers | on items subscription card type if there is a stripe image
	    @ValidateIf((o) => [CardType.ITEMS_SUBSCRIPTION].includes(o.cardType) && o.stripUrl)
	    @IsOptional()
	    @IsNumber()
	    @Min(1)
	    stickersCount: number;
	
	    /*
	     * Loyalty Card Template Validation
	     * */
	
	    // pointsPerVisit
	    @ValidateIf((o) => o.cardType === CardType.LOYALTY)
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    pointsPerVisit: number;
	
	    // gifts
	    @ValidateIf((o) => o.cardType === CardType.LOYALTY)
	    @IsArray()
	    @ArrayMinSize(1)
	    @ValidateNested({ each: true })
	    @Type(() => CreateLoyaltyGiftDto)
	    gifts: CreateLoyaltyGiftDto[];
	
	    /* Event Ticket Card Template Validation */
	
	    // event id
	    @ValidateIf((o) => o.cardType === CardType.EVENT_TICKET)
	    @IsNotEmpty()
	    @IsNumber()
	    eventId: number;
	
	    // event ticket type
	    @ValidateIf((o) => o.cardType === CardType.EVENT_TICKET)
	    @IsNotEmpty()
	    @IsString()
	    @IsEnum(EventTicketType)
	    eventTicketType: EventTicketType;
	
	}
```

modules/card-templates/dto/create-loyalty-gift.dto.ts:
```
	import { IsNotEmpty, IsNumber, IsOptional, IsPositive, IsString, Min } from 'class-validator';
	
	export class CreateLoyaltyGiftDto {
	    // name
	    @IsNotEmpty()
	    @IsString()
	    name: string;
	
	    // limitedAmount
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    limitedAmount: number;
	
	    // priceNPoints
	    @IsNotEmpty()
	    @IsNumber()
	    @IsPositive()
	    priceNPoints: number;
	}
```

modules/card-templates/dto/update-card-template.ts:
```
	import { Type } from 'class-transformer';
	import { IsNotEmpty, IsNumber, IsObject, IsOptional, IsString, Min, ValidateNested } from 'class-validator';
	
	export class UpdateBaseCardTemplateDto {
	    // name
	    @IsOptional()
	    @IsNotEmpty()
	    @IsString()
	    name?: string;
	}
	
	export class UpdateIemsSubscriptionCardTemplateDto {
	    // maxDailyUsage
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    maxDailyUsage?: number;
	
	    // subscriptionDurationDays
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    subscriptionDurationDays?: number;
	
	    // nItems
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    nItems?: number;
	}
	
	export class UpdateCardTemplateDto {
	    // base
	    @IsOptional()
	    @IsNotEmpty()
	    @IsObject()
	    @ValidateNested()
	    @Type(() => UpdateBaseCardTemplateDto)
	    base?: UpdateBaseCardTemplateDto;
	
	    /*
	     * Items Subscription Card Template Validation
	     * */
	    // itemsSubscription
	    @IsOptional()
	    @IsNotEmpty()
	    @IsObject()
	    @ValidateNested()
	    @Type(() => UpdateIemsSubscriptionCardTemplateDto)
	    itemsSubscription?: UpdateIemsSubscriptionCardTemplateDto;
	}
```

modules/card-templates/models/card-template.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Business } from '../../businesses/models/business.model';
	import { LoyaltyCardTemplate } from './loyalty-card-template.model';
	import { ItemsSubscriptionCardTemplate } from './items-subscription-card-template.model';
	import { Card } from '../../cards/models/card.model';
	import { StickerDto } from '../dto/create-card-template';
	import { EventTicketTemplate } from './event-ticket-template.model';
	
	export enum CardType {
	    LOYALTY = 'LOYALTY',
	    ITEMS_SUBSCRIPTION = 'ITEMS_SUBSCRIPTION',
	    EVENT_TICKET = 'EVENT_TICKET',
	    COUPON = 'COUPON',
	}
	
	export class CardTemplate extends Model {
	    public declare id: number;
	    public name!: string;
	    public cardType!: CardType;
	    public businessId!: number;
	    public design: any;
	
	    // images
	    public readonly logoUrl: string;
	    public readonly iconUrl: string;
	    public readonly thumbnailUrl: string;
	    public readonly footerUrl: string;
	    public readonly stripUrl: string;
	    public readonly backgroundUrl: string;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	
	    // associations
	    public readonly business?: Business;
	
	    // stickers
	    public stickers: StickerDto[];
	    public stickersCount: number;
	}
	
	export const init = (sequelize: Sequelize) =>
	    CardTemplate.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            name: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            cardType: {
	                type: DataTypes.STRING,
	                allowNull: false,
	                validate: {
	                    isIn: [Object.values(CardType)],
	                },
	            },
	            businessId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            logoUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            iconUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            thumbnailUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            footerUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            stripUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            backgroundUrl: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            design: {
	                type: DataTypes.JSON,
	                allowNull: true,
	            },
	            stickers: {
	                type: DataTypes.JSON,
	                allowNull: true,
	            },
	            stickersCount: {
	                type: DataTypes.INTEGER,
	                allowNull: true,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'card_templates',
	        },
	    );
	
	export const associate = () => {
	    // Business | Card Template
	    CardTemplate.belongsTo(Business, {
	        foreignKey: 'businessId',
	        as: 'business',
	    });
	
	    // Card Template | Loyalty Card Template
	    CardTemplate.hasOne(LoyaltyCardTemplate, {
	        foreignKey: 'id',
	        as: 'loyaltyCardTemplate',
	        onDelete: 'CASCADE',
	    });
	
	    // Card Template | Items Subscription Card Template
	    CardTemplate.hasOne(ItemsSubscriptionCardTemplate, {
	        foreignKey: 'id',
	        as: 'itemsSubscriptionCardTemplate',
	        onDelete: 'CASCADE',
	    });
	
	    CardTemplate.hasOne(EventTicketTemplate, {
	        foreignKey: 'id',
	        as: 'eventTicketTemplate',
	        onDelete: 'CASCADE',
	    });
	
	    // Card Template | Card
	    CardTemplate.hasMany(Card, {
	        foreignKey: 'cardTemplateId',
	        as: 'cards',
	    });
	};
```

modules/card-templates/models/event-ticket-template.model.ts:
```
	import { DataTypes, Model, Sequelize } from 'sequelize';
	import { Event } from '../../events/models/event.model';
	import { CardTemplate } from './card-template.model';
	
	export enum EventTicketType {
	    SEAT = 'seat',
	    ENTRY = 'entry',
	}
	
	export class EventTicketTemplate extends Model {
	    public declare id: number;
	    public eventId!: number;
	    public event?: Event;
	    public type: EventTicketType;
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    EventTicketTemplate.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	                autoIncrement: true,
	            },
	            eventId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            type: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'event_ticket_templates',
	        },
	    );
	
	export const associate = () => {
	    // Event | Event Ticket Template
	    EventTicketTemplate.belongsTo(Event, {
	        foreignKey: 'eventId',
	        as: 'event',
	    });
	
	    // Event Ticket Template | Card Template
	    EventTicketTemplate.belongsTo(CardTemplate, {
	        foreignKey: 'id',
	        as: 'cardTemplate',
	    });
	};
```

modules/card-templates/models/items-subscription-card-template.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { StickerDto } from '../dto/create-card-template';
	import { CardTemplate } from './card-template.model';
	
	export class ItemsSubscriptionCardTemplate extends Model {
	    public declare id: number;
	    public maxDailyUsage!: number;
	    public subscriptionDurationDays!: number;
	    public nItems!: number;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    ItemsSubscriptionCardTemplate.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	            },
	            maxDailyUsage: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	                validate: {
	                    min: 1,
	                },
	            },
	            subscriptionDurationDays: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	                validate: {
	                    min: 1,
	                },
	            },
	            nItems: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	                validate: {
	                    min: 1,
	                },
	            },
	        },
	        {
	            sequelize,
	            tableName: 'items_subscription_card_templates',
	        },
	    );
	
	export const associate = () => {
	    // Card Template | Items Subscription Card Template
	    ItemsSubscriptionCardTemplate.belongsTo(CardTemplate, {
	        foreignKey: 'id',
	        as: 'cardTemplate',
	    });
	};
```

modules/card-templates/models/loyalty-card-template.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { CardTemplate } from './card-template.model';
	import { LoyaltyGift } from './loyalty-gift.model';
	
	export class LoyaltyCardTemplate extends Model {
	    public declare id: number;
	    public pointsPerVisit: number;
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    LoyaltyCardTemplate.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	            },
	            pointsPerVisit: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'loyalty_card_templates',
	        },
	    );
	
	export const associate = () => {
	    // Card Template | Loyalty Card Template
	    LoyaltyCardTemplate.belongsTo(CardTemplate, {
	        foreignKey: 'id',
	        as: 'cardTemplate',
	    });
	
	    // Loyalty Card Template | Loyalty Gift
	    LoyaltyCardTemplate.hasMany(LoyaltyGift, {
	        foreignKey: 'loyaltyCardTemplateId',
	        as: 'loyaltyGifts',
	        onDelete: 'CASCADE',
	    });
	};
```

modules/card-templates/models/loyalty-gift.model.ts:
```
	import { DataTypes, Model, Sequelize } from 'sequelize';
	import { LoyaltyCardTemplate } from './loyalty-card-template.model';
	import { Activity } from '../../businesses/models/activity.model';
	
	export class LoyaltyGift extends Model {
	    public declare id: number;
	    public name: string;
	    public loyaltyCardTemplateId: number;
	    public limitedAmount?: number;
	    public priceNPoints: number;
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    LoyaltyGift.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	                autoIncrement: true,
	            },
	            name: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            limitedAmount: {
	                type: DataTypes.INTEGER,
	                allowNull: true,
	            },
	            priceNPoints: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            loyaltyCardTemplateId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'loyalty_gifts',
	        },
	    );
	
	export const associate = () => {
	    // Loyal Card Template | Loyalty Gift
	    LoyaltyGift.belongsTo(LoyaltyCardTemplate, {
	        foreignKey: 'loyaltyCardTemplateId',
	        as: 'loyaltyCardTemplate',
	    });
	
	    // Loyalty Gift | Activity
	    LoyaltyGift.hasMany(Activity, {
	        foreignKey: 'relatedId',
	        as: 'activities',
	        constraints: false,
	        scope: {
	            relatedType: 'loyaltyGift',
	        },
	    });
	};
```

modules/card-templates/services/index.ts:
```
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { CardTemplate, CardType } from '../models/card-template.model';
	import { ItemsSubscriptionCardTemplate } from '../models/items-subscription-card-template.model';
	import { LoyaltyCardTemplate } from '../models/loyalty-card-template.model';
	import { CardDesignType, CreateCardTemplateDto } from '../dto/create-card-template';
	import { UpdateCardTemplateDto } from '../dto/update-card-template';
	import path from 'path';
	import fs from 'fs';
	import { APPLE_PASS_PLACEHOLDER } from '../../apple-passes/consts';
	import { downloadImageToFolder } from '../../../helpers';
	import { LoyaltyGift } from '../models/loyalty-gift.model';
	import { CreateLoyaltyGiftDto } from '../dto/create-loyalty-gift.dto';
	import { BUCKET_NAME, deleteFolder, uploadFile } from '../../aws/s3';
	import { EventTicketTemplate } from '../models/event-ticket-template.model';
	import { Event } from '../../events/models/event.model';
	
	export const createCardTemplate = async (
	    createCardTemplateDto: CreateCardTemplateDto,
	    businessId: number,
	    req: RequestMod,
	): Promise<any> => {
	    // define variables to be used in the try catch block
	    let subCardTemplate: LoyaltyCardTemplate | ItemsSubscriptionCardTemplate | EventTicketTemplate;
	    let cardTemplate: CardTemplate;
	    let applePassDesign;
	
	    try {
	        /*
	         * create a base card template
	         * then a sub card template based on the card type
	         */
	
	        const { cardType } = createCardTemplateDto;
	
	        // validate Loyalty Card Template Stickers
	        if (cardType === CardType.LOYALTY && createCardTemplateDto.stickers) {
	            // loyalty cards can only have one sticker
	            if (createCardTemplateDto.stickers.length > 1)
	                throw new HttpError(400, 'Loyalty cards can only have one sticker');
	            createCardTemplateDto.stickersCount = 1;
	        }
	
	        // Create a base card template
	        cardTemplate = await CardTemplate.create({
	            ...createCardTemplateDto,
	            businessId,
	        });
	
	        // create a design json
	        [applePassDesign] = await generateDesignJson({
	            cardTemplateId: cardTemplate.id,
	            ...createCardTemplateDto,
	        });
	
	        cardTemplate.design = applePassDesign;
	        cardTemplate.save();
	
	        // Create a sub card template based on the card type
	        switch (cardType) {
	            case CardType.LOYALTY:
	                subCardTemplate = await LoyaltyCardTemplate.create({
	                    id: cardTemplate.id,
	                    pointsPerVisit: createCardTemplateDto.pointsPerVisit,
	                });
	
	                // add gifts
	                await LoyaltyGift.bulkCreate(
	                    createCardTemplateDto.gifts.map((gift) => ({
	                        ...gift,
	                        loyaltyCardTemplateId: cardTemplate.id,
	                    })),
	                );
	                ``;
	                break;
	
	            case CardType.ITEMS_SUBSCRIPTION:
	                subCardTemplate = await ItemsSubscriptionCardTemplate.create({
	                    id: cardTemplate.id,
	                    maxDailyUsage: createCardTemplateDto.maxDailyUsage,
	                    subscriptionDurationDays: createCardTemplateDto.subscriptionDurationDays,
	                    nItems: createCardTemplateDto.nItems,
	                });
	                break;
	
	            case CardType.EVENT_TICKET:
	                // find event
	                const event = await Event.findOne({
	                    where: {
	                        id: createCardTemplateDto.eventId,
	                    },
	                });
	                if (!event) throw new HttpError(404, 'Event not found');
	
	                // check if the event belongs to the business
	                if (event.businessId !== businessId) throw new HttpError(403, 'Event does not belong to the business');
	
	                subCardTemplate = await EventTicketTemplate.create({
	                    id: cardTemplate.id,
	                    eventId: createCardTemplateDto.eventId,
	                    type: createCardTemplateDto.eventTicketType,
	                });
	                break;
	        }
	
	        // combine the base card template with the sub card template in a single object
	        return {
	            ...cardTemplate.toJSON(),
	            ...subCardTemplate.toJSON(),
	        };
	    } catch (error) {
	        console.error(error);
	
	        /* rollback if any error occurs */
	        // delete the sub card template
	        if (subCardTemplate) await subCardTemplate.destroy();
	        // delete the base card template
	        if (cardTemplate) await cardTemplate.destroy();
	
	        // continue throwing the error
	        throw error;
	    }
	};
	
	const generateDesignJson = async (
	    cardTemplateProps: CreateCardTemplateDto & { cardTemplateId: number },
	): Promise<[any]> => {
	    const { cardProps, designType, qrCodeFormat } = cardTemplateProps;
	
	    // create JSON files for apple and google passes
	    const applePassDesign = {
	        ...cardProps,
	        ...APPLE_PASS_PLACEHOLDER({
	            serialNumber: 'SERIAL_NUMBER',
	            description: 'Zajil Pass',
	            organizationName: `Oraganization Name`,
	            designType,
	            qrCodeMessage: 'QR_CODE_MESSAGE',
	            qrCodeFormat,
	        }),
	    };
	
	    return [applePassDesign];
	};
	
	export const findAllCardTemplates = async ({
	    limit = 10,
	    offset = 0,
	    businessId,
	    req,
	}: {
	    limit: number;
	    offset: number;
	    businessId: number;
	    req: RequestMod;
	}) => {
	    return CardTemplate.findAndCountAll({
	        where: {
	            businessId,
	        },
	        include: FIND_INCLUDE_OPTIONS,
	        limit,
	        offset,
	    }).then((result) => {
	        // remove null fields from each row
	        result.rows = result.rows.map(removeRowNullFields);
	
	        // include card JSON design
	        result.rows = result.rows.map(parseDesign);
	        return result;
	    });
	};
	
	export const findOneCardTemplateById = async (cardTemplateId: number, businessId: number): Promise<any> => {
	    return CardTemplate.findOne({
	        where: {
	            id: cardTemplateId,
	            businessId,
	        },
	        include: FIND_INCLUDE_OPTIONS,
	    }).then((row) => {
	        if (!row) throw new HttpError(404, 'Card template not found');
	        row = removeRowNullFields(row);
	        row = parseDesign(row);
	        return row;
	    });
	};
	
	export const updateCardTemplateById = async (
	    cardTemplateId: number,
	    businessId: number,
	    updateCardTemplateDto: CreateCardTemplateDto,
	): Promise<any> => {
	    // define variables to be used in the try catch block
	    let subCardTemplate: LoyaltyCardTemplate | ItemsSubscriptionCardTemplate | EventTicketTemplate;
	    let cardTemplate: CardTemplate;
	    let applePassDesign: any;
	
	    /*
	     * create a  base card template
	     * then a sub card template based on the card type
	     */
	
	    const { cardType } = updateCardTemplateDto;
	
	    // Create a base card template
	    await CardTemplate.update(
	        {
	            name: updateCardTemplateDto.name,
	            cardType: updateCardTemplateDto.cardType,
	            businessId,
	            design: applePassDesign,
	
	            // images
	            logoUrl: updateCardTemplateDto.logoUrl || null,
	            iconUrl: updateCardTemplateDto.iconUrl || null,
	            thumbnailUrl: updateCardTemplateDto.thumbnailUrl || null,
	            footerUrl: updateCardTemplateDto.footerUrl || null,
	            stripUrl: updateCardTemplateDto.stripUrl || null,
	            backgroundUrl: updateCardTemplateDto.backgroundUrl || null,
	        },
	        {
	            where: {
	                id: cardTemplateId,
	            },
	        },
	    );
	    cardTemplate = await CardTemplate.findOne({
	        where: {
	            id: cardTemplateId,
	        },
	    });
	
	    // generate the design JSON
	    [applePassDesign] = await generateDesignJson({
	        cardTemplateId: cardTemplate.id,
	        ...updateCardTemplateDto,
	    });
	
	    cardTemplate.design = applePassDesign;
	    await cardTemplate.save();
	
	    // Create a sub card template based on the card type
	    switch (cardType) {
	        case CardType.LOYALTY:
	            await LoyaltyCardTemplate.update(
	                {
	                    pointsPerVisit: updateCardTemplateDto.pointsPerVisit,
	                },
	                {
	                    where: {
	                        id: cardTemplate.id,
	                    },
	                },
	            );
	            subCardTemplate = await LoyaltyCardTemplate.findOne({
	                where: {
	                    id: cardTemplate.id,
	                },
	            });
	            break;
	
	        case CardType.ITEMS_SUBSCRIPTION:
	            // update the existing sub card template
	            await ItemsSubscriptionCardTemplate.update(
	                {
	                    maxDailyUsage: updateCardTemplateDto.maxDailyUsage,
	                    subscriptionDurationDays: updateCardTemplateDto.subscriptionDurationDays,
	                    nItems: updateCardTemplateDto.nItems,
	                    stickers: updateCardTemplateDto.stickers,
	                    stickersCount: updateCardTemplateDto.stickersCount,
	                },
	                {
	                    where: {
	                        id: cardTemplate.id,
	                    },
	                },
	            );
	            subCardTemplate = await ItemsSubscriptionCardTemplate.findOne({
	                where: {
	                    id: cardTemplate.id,
	                },
	            });
	            break;
	
	        case CardType.EVENT_TICKET:
	            // update the existing sub card template
	            await EventTicketTemplate.update(
	                {
	                    eventId: updateCardTemplateDto.eventId,
	                    type: updateCardTemplateDto.eventTicketType,
	                },
	                {
	                    where: {
	                        id: cardTemplate.id,
	                    },
	                },
	            );
	            subCardTemplate = await EventTicketTemplate.findOne({
	                where: {
	                    id: cardTemplate.id,
	                },
	            });
	            break;
	    }
	
	    // combine the base card template with the sub card template in a single object
	    return {
	        ...cardTemplate.toJSON(),
	        ...subCardTemplate.toJSON(),
	    };
	};
	
	export const deleteCardTemplateById = async (cardTemplateId: number) => {
	    const res = await CardTemplate.destroy({
	        where: {
	            id: cardTemplateId,
	        },
	    });
	
	    await deleteFolder(`card-templates/${cardTemplateId}`);
	
	    return res;
	};
	
	// Helpers
	
	const FIND_INCLUDE_OPTIONS = [
	    {
	        model: LoyaltyCardTemplate,
	        as: 'loyaltyCardTemplate',
	        where: {
	            '$CardTemplate.cardType$': CardType.LOYALTY,
	        },
	        required: false,
	        include: [
	            {
	                model: LoyaltyGift,
	                as: 'loyaltyGifts',
	                required: false,
	            },
	        ],
	    },
	    {
	        model: ItemsSubscriptionCardTemplate,
	        as: 'itemsSubscriptionCardTemplate',
	        where: {
	            '$CardTemplate.cardType$': CardType.ITEMS_SUBSCRIPTION,
	        },
	        required: false,
	    },
	    {
	        model: EventTicketTemplate,
	        as: 'eventTicketTemplate',
	        where: {
	            '$CardTemplate.cardType$': CardType.EVENT_TICKET,
	        },
	        required: false,
	        include: [
	            {
	                model: Event,
	                as: 'event',
	                required: false,
	            },
	        ],
	    },
	];
	
	const removeRowNullFields = (row: CardTemplate) => {
	    row = row.toJSON();
	    for (const key in row) if (row[key] === null) delete row[key];
	    return row;
	};
	
	export const addGiftToLoyaltyCardTemplate = async (cardTemplateId: number, body: CreateLoyaltyGiftDto) => {
	    // find the loyalty card template
	    const loyaltyCardTemplate = await LoyaltyCardTemplate.findOne({
	        where: {
	            id: cardTemplateId,
	        },
	    });
	    if (!loyaltyCardTemplate) throw new HttpError(404, 'Card template not found');
	
	    // create the gift
	    const gift = await LoyaltyGift.create({
	        ...body,
	        loyaltyCardTemplateId: loyaltyCardTemplate.id,
	    });
	
	    return gift;
	};
	export const updateGiftInLoyaltyCardTemplate = async (
	    cardTemplateId: number,
	    giftId: number,
	    body: CreateLoyaltyGiftDto,
	) => {
	    // find the loyalty card template
	    const loyaltyCardTemplate = await LoyaltyCardTemplate.findOne({
	        where: {
	            id: cardTemplateId,
	        },
	    });
	    if (!loyaltyCardTemplate) throw new HttpError(404, 'Card template not found');
	
	    // find the gift
	    const gift = await LoyaltyGift.findOne({
	        where: {
	            id: giftId,
	            loyaltyCardTemplateId: loyaltyCardTemplate.id,
	        },
	    });
	    if (!gift) throw new HttpError(404, 'Gift not found');
	
	    // update the gift
	    await gift.update(body);
	
	    return gift;
	};
	export const deleteGiftFromLoyaltyCardTemplate = async (cardTemplateId: number, giftId: number) => {
	    // find the loyalty card template
	    const loyaltyCardTemplate = await LoyaltyCardTemplate.findOne({
	        where: {
	            id: cardTemplateId,
	        },
	    });
	    if (!loyaltyCardTemplate) throw new HttpError(404, 'Card template not found');
	
	    // find the gift
	    const gift = await LoyaltyGift.findOne({
	        where: {
	            id: giftId,
	            loyaltyCardTemplateId: loyaltyCardTemplate.id,
	        },
	    });
	    if (!gift) throw new HttpError(404, 'Gift not found');
	
	    // delete the gift
	    await gift.destroy();
	
	    return gift;
	};
	
	function parseDesign(row: any) {
	    const cardJSONObj = row.design;
	
	    // filter out some fields
	    delete cardJSONObj.formatVersion;
	    delete cardJSONObj.passTypeIdentifier;
	    delete cardJSONObj.teamIdentifier;
	    delete cardJSONObj.serialNumber;
	    delete cardJSONObj.description;
	    delete cardJSONObj.organizationName;
	    delete cardJSONObj.barcode.message;
	
	    row.design = cardJSONObj;
	    return row;
	}
```

modules/cards/controllers/Card.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import * as cardServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { CreateCardDto } from '../dto/create-card';
	import { UpdateCardDto } from '../dto/update-card';
	
	export const CardController: ICRUDController & {
	    loyaltyAddPoints: (req: RequestMod, res: Response, next: NextFunction) => void;
	    loyaltyUpdatePoints: (req: RequestMod, res: Response, next: NextFunction) => void;
	    loyaltyRedeemGift: (req: RequestMod, res: Response, next: NextFunction) => void;
	    itemSubscriptionUse: (req: RequestMod, res: Response, next: NextFunction) => void;
	    registerDevice: (req: RequestMod, res: Response, next: NextFunction) => void;
	    unregisterDevice: (req: RequestMod, res: Response, next: NextFunction) => void;
	    getSerialNumbers: (req: RequestMod, res: Response, next: NextFunction) => void;
	    sendUpdatedPass: (req: RequestMod, res: Response, next: NextFunction) => void;
	    log: (req: RequestMod, res: Response, next: NextFunction) => void;
	    scanTicket: (req: RequestMod, res: Response, next: NextFunction) => void;
	} = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const body: CreateCardDto = req.body;
	
	        cardServices
	            .createCard(body, req)
	            .then((card) => res.status(201).json(card))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	
	        cardServices
	            .findOneCardById(cardId, req)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	        const businessId = Number(req.params.businessId);
	        const sort = req.query.sort === 'asc' ? 'asc' : 'desc';
	
	        cardServices
	            .findAllCards({ limit, offset, req, businessId, sort })
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	        const businessId = Number(req.params.businessId);
	        const body: UpdateCardDto = req.body;
	
	        cardServices
	            .updateCardById(cardId, businessId, body, req)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	
	        cardServices
	            .deleteCardById(cardId)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    // Custom methods
	
	    loyaltyAddPoints: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	
	        cardServices
	            .loyaltyAddPoints(cardId, req.user)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    loyaltyUpdatePoints: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	        const points = Number(req.body.points);
	
	        cardServices
	            .loyaltyUpdatePoints(cardId, points, req.user)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    loyaltyRedeemGift: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	        const giftId = Number(req.body.giftId);
	
	        cardServices
	            .loyaltyRedeemGift(cardId, giftId, req.user)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    itemSubscriptionUse: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	
	        cardServices
	            .itemsSubscriptionUseItems(cardId, req.body, req.user)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    registerDevice: function (req: Request, res: Response, next: NextFunction): void {
	        const serialNumber = Number(req.params.serialNumber);
	        const deviceLibraryIdentifier = req.params.deviceLibraryIdentifier;
	        const pushToken = req.body.pushToken;
	
	        console.log(serialNumber, pushToken);
	
	        cardServices
	            .registerDevice({ serialNumber, pushToken, deviceLibraryIdentifier })
	            .then((card) => res.status(201).json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    unregisterDevice: function (req: Request, res: Response, next: NextFunction): void {
	        const deviceLibraryIdentifier = req.params.deviceLibraryIdentifier;
	        const passTypeIdentifier = req.params.passTypeIdentifier;
	        const serialNumber = Number(req.params.serialNumber);
	
	        cardServices
	            .unregisterDevice({ deviceLibraryIdentifier, passTypeIdentifier, serialNumber })
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    getSerialNumbers: function (req: Request, res: Response, next: NextFunction): void {
	        const deviceLibraryIdentifier = req.params.deviceLibraryIdentifier;
	
	        cardServices
	            .getSerialNumbers({
	                deviceLibraryIdentifier,
	            })
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    sendUpdatedPass: function (req: Request, res: Response, next: NextFunction): void {
	        const passTypeIdentifier = req.params.passTypeIdentifier;
	        const serialNumber = Number(req.params.serialNumber);
	
	        cardServices
	            .sendUpdatedPass({ passTypeIdentifier, serialNumber })
	            .then((pkpassBuffer) => {
	                res.writeHead(200, {
	                    'Content-Type': 'application/vnd.apple.pkpass',
	                    'Content-disposition': 'attachment;filename=' + 'pass.pkpass',
	                });
	                res.end(pkpassBuffer);
	            })
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    scanTicket: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const cardId = Number(req.params.id);
	
	        cardServices
	            .scanTicket(cardId, req.user)
	            .then((card) => res.json(card))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    log: function (req: Request, res: Response, next: NextFunction): void {
	        const logs = req.body.logs;
	        console.log(logs);
	    },
	};
```

modules/cards/dto/create-card.ts:
```
	import { IsDateString, IsEnum, IsIn, IsNotEmpty, IsNumber, IsOptional, IsString, Matches, Min } from 'class-validator';
	import { Gender } from '../models/card.model';
	
	export class CreateCardDto {
	    // clientPhone
	    @IsNotEmpty()
	    @IsString()
	    clientPhone: string;
	
	    // clientName
	    @IsNotEmpty()
	    @IsString()
	    clientName: string;
	
	    // gender
	    @IsOptional()
	    @IsString()
	    @IsEnum(Gender)
	    gender: string;
	
	    // dob
	    @IsOptional()
	    @IsDateString()
	    dob: string;
	
	    // templateId
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    templateId: number;
	
	    // seat
	    @IsOptional()
	    @IsString()
	    @Matches(/^[A-Z]\d+$/) // ex: 'A1'
	    seat?: string;
	}
```

modules/cards/dto/items-sub-use.ts:
```
	import { Type } from 'class-transformer';
	import { IsArray, IsNotEmpty, IsNumber, IsOptional, Min, ValidateNested } from 'class-validator';
	import { StickerDto } from '../../card-templates/dto/create-card-template';
	import { IsStickersLengthEqualToValue } from './validators/stickers-len-e-value';
	
	export class ItemsSubUseDto {
	    // value
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    value: number;
	
	    // stickers
	    @IsOptional()
	    @IsNotEmpty()
	    @IsArray()
	    @IsStickersLengthEqualToValue()
	    @ValidateNested({ each: true })
	    @Type(() => StickerDto)
	    stickers: StickerDto[];
	}
```

modules/cards/dto/loyalty-add-subtract-points.ts:
```
	import { IsNotEmpty, IsNumber, Min } from 'class-validator';
	
	export class LoyaltyAddSubtractPoints {
	    // value
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(1)
	    value: number;
	}
```

modules/cards/dto/update-card.ts:
```
	import { Type } from 'class-transformer';
	import { IsNotEmpty, IsNumber, IsObject, IsOptional, IsString, Min, ValidateNested } from 'class-validator';
	
	export class UpdateBaseCardDto {
	    // clientName
	    @IsOptional()
	    @IsNotEmpty()
	    @IsString()
	    clientName?: string;
	
	    // clientPhone
	    @IsOptional()
	    @IsNotEmpty()
	    @IsString()
	    clientPhone?: string;
	}
	
	export class UpdateIemsSubscriptionCardDto {
	    // nItems
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(0)
	    nItems?: number;
	}
	
	export class UpdateLoyaltyCardDto {
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Min(0)
	    points?: number;
	}
	
	export class UpdateCardDto {
	    // base
	    @IsOptional()
	    @IsNotEmpty()
	    @IsObject()
	    @ValidateNested()
	    @Type(() => UpdateBaseCardDto)
	    base?: UpdateBaseCardDto;
	
	    /*
	     * Items Subscription Card Validation
	     * */
	    // itemsSubscription
	    @IsOptional()
	    @IsNotEmpty()
	    @IsObject()
	    @ValidateNested()
	    @Type(() => UpdateIemsSubscriptionCardDto)
	    itemsSubscriptionCard?: UpdateIemsSubscriptionCardDto;
	
	    /*
	     * Loyalty Card Validation
	     * */
	    // loyalty
	    @IsOptional()
	    @IsNotEmpty()
	    @IsObject()
	    @ValidateNested()
	    @Type(() => UpdateLoyaltyCardDto)
	    loyaltyCard?: UpdateLoyaltyCardDto;
	}
```

modules/cards/dto/validators/stickers-len-e-value.ts:
```
	import { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';
	
	export function IsStickersLengthEqualToValue(validationOptions?: ValidationOptions) {
	    return function (object: Object, propertyName: string): void {
	        registerDecorator({
	            name: 'isStickersLengthEqualToValue',
	            target: object.constructor,
	            propertyName: propertyName,
	            options: validationOptions,
	            validator: {
	                validate(value: any, args: ValidationArguments) {
	                    const stickers = args.object['stickers'] as any[];
	                    const valueProp = args.object['value'] as number;
	
	                    if (!stickers || !Array.isArray(stickers)) {
	                        return false;
	                    }
	
	                    return stickers.length === valueProp;
	                },
	                defaultMessage(args: ValidationArguments) {
	                    return `The length of stickers must be equal to the value of "value"`;
	                },
	            },
	        });
	    };
	}
```

modules/cards/models/card.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { StickerDto } from '../../card-templates/dto/create-card-template';
	import { CardTemplate } from '../../card-templates/models/card-template.model';
	import { LoyaltyCard } from './loyalty-card.model';
	import { ItemsSubscriptionCard } from './items-subscription-card.model';
	import { Activity, ActivityType } from '../../businesses/models/activity.model';
	import { LoyaltyGift } from '../../card-templates/models/loyalty-gift.model';
	import { EventCard } from './event-card.model';
	
	export enum Gender {
	    MALE = 'male',
	    FEMALE = 'female',
	}
	export class Card extends Model {
	    public declare id: number;
	    public clientPhone!: string;
	    public clientName!: string;
	    public gender?: string;
	    public dob?: Date;
	    public templateId!: number;
	    public deviceLibraryIdentifier: string;
	    public pushToken: string;
	    public s3Key: string;
	    public s3Location: string;
	
	    // choosen tickers
	    public chosenStickers: StickerDto[];
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	
	    // associations
	    public readonly cardTemplate?: CardTemplate;
	
	    public canScan: boolean;
	
	    // methods
	    // for loyalty card, it has a 10 minutes cooldown
	    public loyaltyCanScan = async (): Promise<boolean> => {
	        let scannable: boolean = true;
	        const lastActivity = await Activity.findOne({
	            where: {
	                relatedId: this.id,
	                relatedType: 'card',
	                types: [ActivityType.SCAN_CARD],
	            },
	            order: [['createdAt', 'DESC']],
	        });
	        if (!lastActivity) {
	            scannable = true;
	        } else {
	            const now = new Date();
	            const lastActivityDate = new Date(lastActivity.createdAt);
	            const diff = now.getTime() - lastActivityDate.getTime();
	            const diffMinutes = Math.ceil(diff / (1000 * 60));
	            scannable = diffMinutes >= 10;
	        }
	
	        if (scannable != this.canScan) {
	            this.canScan = scannable;
	            await this.save();
	        }
	
	        return scannable;
	    };
	}
	
	export const init = (sequelize: Sequelize) =>
	    Card.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            clientPhone: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            clientName: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            gender: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            dob: {
	                type: DataTypes.DATE,
	                allowNull: true,
	            },
	            templateId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            deviceLibraryIdentifier: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            pushToken: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            chosenStickers: {
	                type: DataTypes.JSON,
	                allowNull: true,
	            },
	            s3Key: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            s3Location: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            canScan: {
	                type: DataTypes.BOOLEAN,
	                allowNull: true,
	                defaultValue: true,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'cards',
	        },
	    );
	
	export const associate = () => {
	    // Card Template | Card
	    Card.belongsTo(CardTemplate, {
	        foreignKey: 'templateId',
	        as: 'cardTemplate',
	    });
	
	    // Card | Loyalty Card
	    Card.hasOne(LoyaltyCard, {
	        foreignKey: 'id',
	        as: 'loyaltyCard',
	        onDelete: 'CASCADE',
	    });
	
	    Card.hasOne(ItemsSubscriptionCard, {
	        foreignKey: 'id',
	        as: 'itemsSubscriptionCard',
	        onDelete: 'CASCADE',
	    });
	
	    Card.hasOne(EventCard, {
	        foreignKey: 'id',
	        as: 'eventCard',
	        onDelete: 'CASCADE',
	    });
	
	    // Card | Activity
	    Card.hasMany(Activity, {
	        foreignKey: 'relatedId',
	        as: 'activities',
	        onDelete: 'CASCADE',
	        constraints: false,
	        scope: {
	            relatedType: 'card',
	        },
	    });
	};
```

modules/cards/models/event-card.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Card } from './card.model';
	import { LoyaltyGift } from '../../card-templates/models/loyalty-gift.model';
	import { EventTicketTemplate } from '../../card-templates/models/event-ticket-template.model';
	import { Event } from '../../events/models/event.model';
	
	export class EventCard extends Model {
	    public declare id: number;
	    public eventTicketTemplateId!: number;
	    public seatId?: string; // ex: 'A1'
	    public used: boolean;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	
	    public async isExpired(): Promise<boolean> {
	        const eventTicketTemplate = await EventTicketTemplate.findOne({
	            where: {
	                id: this.eventTicketTemplateId,
	            },
	            include: [
	                {
	                    model: Event,
	                    as: 'event',
	                },
	            ],
	        });
	
	        return eventTicketTemplate.event.endDate < new Date();
	    }
	}
	
	export const init = (sequelize: Sequelize) =>
	    EventCard.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	            },
	            eventTicketTemplateId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            seatId: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            used: {
	                type: DataTypes.BOOLEAN,
	                defaultValue: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'event_cards',
	        },
	    );
	
	export const associate = () => {
	    EventCard.belongsTo(EventTicketTemplate, {
	        foreignKey: 'eventTicketTemplateId',
	        as: 'eventTicketTemplate',
	    });
	};
```

modules/cards/models/items-subscription-card.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Card } from './card.model';
	
	export class ItemsSubscriptionCard extends Model {
	    public declare id: number;
	    public nItems!: number;
	    public expirationDate!: Date;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    ItemsSubscriptionCard.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	            },
	            nItems: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	                validate: {
	                    min: 0,
	                },
	            },
	            expirationDate: {
	                type: DataTypes.DATE,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'items_subscription_cards',
	        },
	    );
	
	export const associate = () => {
	    // Card | Items Subscription Card
	    ItemsSubscriptionCard.belongsTo(Card, {
	        foreignKey: 'id',
	        as: 'card',
	    });
	};
```

modules/cards/models/loyalty-card.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Card } from './card.model';
	import { LoyaltyGift } from '../../card-templates/models/loyalty-gift.model';
	
	export class LoyaltyCard extends Model {
	    public declare id: number;
	    public points!: number;
	    card: Card;
	
	    // redeemed loyalty gifts
	    public redeemedLoyaltyGifts: {
	        id: number;
	        name: string;
	        redeemedAt: Date;
	    }[];
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    LoyaltyCard.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	            },
	            points: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	                validate: {
	                    min: 0,
	                },
	            },
	            redeemedLoyaltyGifts: {
	                type: DataTypes.JSON,
	                allowNull: true,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'loyalty_cards',
	        },
	    );
	
	export const associate = () => {
	    LoyaltyCard.belongsTo(Card, {
	        foreignKey: 'id',
	        as: 'card',
	    });
	};
```

modules/cards/services/index.ts:
```
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { CreateCardDto } from '../dto/create-card';
	import { Card } from '../models/card.model';
	import { CardTemplate, CardType } from '../../card-templates/models/card-template.model';
	import { UpdateCardDto } from '../dto/update-card';
	import { ItemsSubscriptionCardTemplate } from '../../card-templates/models/items-subscription-card-template.model';
	import { LoyaltyCard } from '../models/loyalty-card.model';
	import { ItemsSubscriptionCard } from '../models/items-subscription-card.model';
	import { generatePass } from '../../apple-passes/services';
	import path from 'path';
	import { PKPass } from 'passkit-generator';
	import fs from 'fs';
	import { LoyaltyCardTemplate } from '../../card-templates/models/loyalty-card-template.model';
	import { LoyaltyGift } from '../../card-templates/models/loyalty-gift.model';
	import { ItemsSubUseDto } from '../dto/items-sub-use';
	import { Activity, ActivityType } from '../../businesses/models/activity.model';
	import { User } from '../../users/models/user.model';
	import { Request } from 'express';
	import { getFile, uploadFile } from '../../aws/s3';
	import { Op } from 'sequelize';
	import { EventCard } from '../models/event-card.model';
	import { Event, SeatType } from '../../events/models/event.model';
	import { EventTicketTemplate, EventTicketType } from '../../card-templates/models/event-ticket-template.model';
	import { sendUpdatePassNotification } from '../../notifications/services/apn.service';
	
	export const createCard = async (createCardDto: CreateCardDto, req: Request): Promise<any> => {
	    /*
	     * create a card then create a loyalty card or items subscription card based on the card type
	     */
	
	    // Get card template
	    const cardTemplate = await CardTemplate.findOne({
	        where: {
	            id: createCardDto.templateId,
	        },
	    });
	    if (!cardTemplate) throw new HttpError(404, 'Card template not found');
	
	    // Create a base card
	    const card = await Card.create({
	        ...createCardDto,
	        templateId: cardTemplate.id,
	    });
	
	    // Create a sub card based on the card type
	    let subCard: LoyaltyCard | ItemsSubscriptionCard | EventCard;
	    switch (cardTemplate.cardType) {
	        case CardType.LOYALTY:
	            subCard = await LoyaltyCard.create({
	                id: card.id,
	                points: 0,
	            });
	            break;
	
	        case CardType.ITEMS_SUBSCRIPTION:
	            const isct = await ItemsSubscriptionCardTemplate.findOne({
	                where: {
	                    id: cardTemplate.id,
	                },
	            });
	            subCard = await ItemsSubscriptionCard.create({
	                id: card.id,
	                nItems: isct.nItems,
	                expirationDate: new Date(Date.now() + isct.subscriptionDurationDays * 24 * 60 * 60 * 1000),
	            });
	            break;
	
	        case CardType.EVENT_TICKET:
	            // find event ticket template
	            const eventTicketTemplate = await EventTicketTemplate.findOne({
	                where: {
	                    id: cardTemplate.id,
	                },
	                include: [
	                    {
	                        model: Event,
	                        as: 'event',
	                        required: true,
	                    },
	                ],
	            });
	            if (!eventTicketTemplate) throw new HttpError(404, 'Event ticket template not found');
	
	            // check if the event has a limited amount
	            if (eventTicketTemplate.event.limitedAmount) {
	                const nTickets = await EventCard.count({
	                    where: {
	                        eventTicketTemplateId: eventTicketTemplate.id,
	                    },
	                });
	                if (nTickets >= eventTicketTemplate.event.limitedAmount)
	                    throw new HttpError(400, 'Event reached its limited amount');
	            }
	
	            // if it has seats, validate the seats
	            if ((eventTicketTemplate.type = EventTicketType.SEAT)) {
	                if (!createCardDto.seat) throw new HttpError(400, '`seat` is required');
	                await validateAndChooseSeat(eventTicketTemplate.event, createCardDto.seat);
	            }
	
	            // create event card
	            subCard = await EventCard.create({
	                id: card.id,
	                eventTicketTemplateId: eventTicketTemplate.id,
	                seatId: createCardDto.seat,
	            });
	            break;
	    }
	
	    // generate the pass in the public folder
	    const cardObj = await generatePassFromTemplate(card.id, cardTemplate.id);
	
	    card.s3Key = cardObj.Key;
	    card.s3Location = cardObj.Location;
	    await card.save();
	
	    // log activity
	    await Activity.create({
	        businessId: cardTemplate.businessId,
	        message: `Card ${card.id} created of type ${cardTemplate.cardType}`,
	        types: [ActivityType.CREATE_CARD],
	        relatedId: card.id,
	        relatedType: 'card',
	    });
	
	    // combine the base card with the sub card in a single object
	    return {
	        ...card.toJSON(),
	        ...subCard.toJSON(),
	    };
	};
	
	const generatePassFromTemplate = async (cardId: number, cardTemplateId: number) => {
	    const pass: PKPass = await generatePass({
	        cardTemplateId: cardTemplateId,
	        cardId: cardId.toString(),
	    });
	
	    // create a folder in the public folder to store the card template files
	    const cardPath = `cards/${cardId}.pkpass`;
	
	    // write the pass to the public folder
	    const passBuffer = pass.getAsBuffer();
	    const obj = await uploadFile(
	        {
	            name: cardPath.split('/').pop(),
	            data: passBuffer,
	            contentType: 'application/vnd.apple.pkpass',
	            ContentDisposition: `attachment; filename=${cardPath.split('/').pop()}`,
	        },
	        cardPath.split('/').slice(0, -1).join('/'),
	    );
	
	    // return the uri using the public folder as the root
	    return obj;
	};
	
	export const findAllCards = async ({
	    limit = 10,
	    offset = 0,
	    businessId,
	    req,
	    sort,
	}: {
	    limit: number;
	    offset: number;
	    businessId: number;
	    req: RequestMod;
	    sort: 'asc' | 'desc';
	}) => {
	    return (
	        Card.findAndCountAll({
	            include: FIND_INCLUDE_OPTIONS(businessId),
	            limit,
	            offset,
	            order: [['id', sort]],
	        })
	            // remove null fields from each row
	            .then((result) => {
	                result.rows = result.rows.map(removeRowNullFields);
	                return result;
	            })
	    );
	};
	
	export const findOneCardById = async (cardId: number, req: RequestMod): Promise<any> => {
	    const userBusinessIds = req.user.businesses.map((b) => b.id);
	    const bussinessesUserWorksFor = req.user.employedAt.map((e) => e.businessId);
	    return Card.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: CardTemplate,
	                as: 'cardTemplate',
	                required: true,
	                include: [
	                    {
	                        model: ItemsSubscriptionCardTemplate,
	                        as: 'itemsSubscriptionCardTemplate',
	                        required: false,
	                    },
	                    {
	                        model: LoyaltyCardTemplate,
	                        as: 'loyaltyCardTemplate',
	                        required: false,
	                        include: [
	                            {
	                                model: LoyaltyGift,
	                                as: 'loyaltyGifts',
	                            },
	                        ],
	                    },
	                ],
	            },
	            {
	                model: LoyaltyCard,
	                as: 'loyaltyCard',
	                required: false,
	            },
	            {
	                model: ItemsSubscriptionCard,
	                as: 'itemsSubscriptionCard',
	                required: false,
	            },
	            {
	                model: Activity,
	                as: 'activities',
	                required: false,
	                limit: 10,
	                order: [['id', 'DESC']],
	            },
	        ],
	    }).then((row) => {
	        if (!row) throw new HttpError(404, 'Card not found');
	
	        // check if the card business belongs to the user
	        if (
	            ![...userBusinessIds, ...bussinessesUserWorksFor].includes(
	                (row as Card & { cardTemplate: CardTemplate }).cardTemplate.businessId,
	            )
	        )
	            throw new HttpError(403, 'Forbidden, card does not belong to any of your businesses');
	
	        return removeRowNullFields(row);
	    });
	};
	
	export const updateCardById = async (
	    cardId: number,
	    businessId: number,
	    updateCardDto: UpdateCardDto,
	    req: RequestMod,
	): Promise<any> => {
	    const baseUpdateDto = updateCardDto.base;
	    const card = await Card.findOne({
	        where: {
	            id: cardId,
	        },
	        include: FIND_INCLUDE_OPTIONS(businessId),
	    });
	    if (!card) throw new HttpError(404, 'Card not found');
	
	    // update the base card
	    if (baseUpdateDto) await card.update(baseUpdateDto);
	
	    const { cardTemplate } = card as Card & { cardTemplate: CardTemplate };
	
	    // update the sub card
	    switch (cardTemplate.cardType) {
	        case CardType.LOYALTY:
	            const loyaltyDto = updateCardDto.loyaltyCard;
	            if (!loyaltyDto) break;
	            const subCard = await LoyaltyCard.update(loyaltyDto, {
	                where: {
	                    id: cardId,
	                },
	            });
	            if (!subCard) throw new HttpError(404, 'Card not found');
	            break;
	
	        case CardType.ITEMS_SUBSCRIPTION:
	            const itemsSubscriptionDto = updateCardDto.itemsSubscriptionCard;
	            if (!itemsSubscriptionDto) break;
	            const subCard2 = await ItemsSubscriptionCard.update(itemsSubscriptionDto, {
	                where: {
	                    id: cardId,
	                },
	            });
	            if (!subCard2) throw new HttpError(404, 'Card not found');
	            break;
	    }
	
	    // log activity
	    await Activity.create({
	        businessId: cardTemplate.businessId,
	        message: `Card ${card.id} updated`,
	        type: [ActivityType.UPDATE_CARD],
	        relatedId: card.id,
	        relatedType: 'card',
	    });
	
	    return findOneCardById(cardId, req);
	};
	
	export const deleteCardById = async (cardId: number) => {
	    return Card.destroy({
	        where: {
	            id: cardId,
	        },
	    });
	};
	
	// loyalty add points
	export const loyaltyAddPoints = async (cardId: number, user: User) => {
	    // find the loyalty card
	    const card = (await Card.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: CardTemplate,
	                as: 'cardTemplate',
	            },
	        ],
	    })) as Card & { cardTemplate: CardTemplate };
	    if (!card) throw new HttpError(404, 'Card not found');
	
	    // Has to be a minimum of 10 minutes between scans
	    if (!(await card.loyaltyCanScan()))
	        throw new HttpError(400, 'You can only add points to a card once every 10 minutes');
	
	    const template = await LoyaltyCardTemplate.findOne({
	        where: {
	            id: card.templateId,
	        },
	    });
	    if (!template) throw new HttpError(404, 'Template not found');
	
	    // find the loyalty card
	    const loyaltyCard = await LoyaltyCard.findOne({
	        where: {
	            id: cardId,
	        },
	    });
	    if (!loyaltyCard) throw new HttpError(404, 'Card not found');
	
	    // add points
	    loyaltyCard.points += template.pointsPerVisit;
	    const newCard = await loyaltyCard.save();
	
	    // log activity
	    await Activity.create({
	        businessId: card.cardTemplate.businessId,
	        message: `Card ${card.id} scanned, ${template.pointsPerVisit} points added`,
	        types: [ActivityType.SCAN_CARD],
	        relatedId: card.id,
	        relatedType: 'card',
	        userId: user.id,
	    });
	    card.canScan = false;
	    await card.save();
	
	    // update the pass
	    await generatePassFromTemplate(cardId, card.templateId);
	
	    await sendUpdatePassNotification(card.pushToken);
	
	    return newCard;
	};
	
	// loyalty subtract points
	export const loyaltySubtractPoints = async (cardId: number, value: number, user: User) => {
	    // find the loyalty card
	    const loyaltyCard = (await LoyaltyCard.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: Card,
	                as: 'card',
	                include: [
	                    {
	                        model: CardTemplate,
	                        as: 'cardTemplate',
	                    },
	                ],
	            },
	        ],
	    })) as LoyaltyCard & { card: Card & { cardTemplate: CardTemplate } };
	    if (!loyaltyCard) throw new HttpError(404, 'Card not found');
	
	    // subtract points
	    if (loyaltyCard.points < value) throw new HttpError(400, 'Not enough points');
	    loyaltyCard.points -= value;
	    await loyaltyCard.save();
	
	    // log activity
	    await Activity.create({
	        businessId: loyaltyCard.card.cardTemplate.businessId,
	        message: `Card ${loyaltyCard.id} scanned, ${value} points subtracted`,
	        type: [ActivityType.SCAN_CARD],
	        relatedId: loyaltyCard.id,
	        relatedType: 'card',
	        userId: user.id,
	    });
	    loyaltyCard.card.canScan = false;
	    await loyaltyCard.card.save();
	
	    // update the pass
	    await generatePassFromTemplate(cardId, loyaltyCard.card.templateId);
	    await sendUpdatePassNotification(loyaltyCard.card.pushToken);
	
	    return loyaltyCard;
	};
	
	// items subscription use items
	export const itemsSubscriptionUseItems = async (cardId: number, body: ItemsSubUseDto, user: User) => {
	    // find the items subscription card
	    const itemsSubscriptionCard = (await ItemsSubscriptionCard.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: Card,
	                as: 'card',
	                include: [
	                    {
	                        model: CardTemplate,
	                        as: 'cardTemplate',
	                    },
	                ],
	            },
	        ],
	    })) as ItemsSubscriptionCard & { card: Card & { cardTemplate: CardTemplate } };
	    if (!itemsSubscriptionCard) throw new HttpError(404, 'Card not found');
	
	    // use items
	
	    // update nItems
	    if (itemsSubscriptionCard.nItems < body.value) throw new HttpError(400, 'Not enough items');
	    itemsSubscriptionCard.nItems -= body.value;
	
	    // update stickers if provided
	    if (body.stickers) {
	        const oldChosenStickers = itemsSubscriptionCard.card.chosenStickers || [];
	        itemsSubscriptionCard.card.chosenStickers = [...oldChosenStickers, ...body.stickers];
	        await itemsSubscriptionCard.card.save();
	    }
	    await itemsSubscriptionCard.save();
	
	    // update the pass
	    await generatePassFromTemplate(cardId, itemsSubscriptionCard.card.templateId);
	    await sendUpdatePassNotification(itemsSubscriptionCard.card.pushToken);
	
	    // log activity
	    await Activity.create({
	        businessId: itemsSubscriptionCard.card.cardTemplate.businessId,
	        message: `Card ${itemsSubscriptionCard.id} scanned, ${body.value} items used`,
	        types: [ActivityType.SCAN_CARD],
	        relatedId: itemsSubscriptionCard.id,
	        relatedType: 'card',
	        userId: user.id,
	    });
	
	    return itemsSubscriptionCard;
	};
	
	// Helpers
	
	const FIND_INCLUDE_OPTIONS = (businessId: number) => [
	    {
	        model: CardTemplate,
	        as: 'cardTemplate',
	        where: {
	            businessId,
	        },
	        required: true,
	    },
	    {
	        model: LoyaltyCard,
	        as: 'loyaltyCard',
	        required: false,
	    },
	    {
	        model: ItemsSubscriptionCard,
	        as: 'itemsSubscriptionCard',
	        required: false,
	    },
	];
	
	const removeRowNullFields = (row) => {
	    row = row.toJSON();
	    for (const key in row) if (row[key] === null) delete row[key];
	    return row;
	};
	
	export const loyaltyRedeemGift = async (cardId: number, giftId: number, user: User) => {
	    // find the loyalty card
	    const loyaltyCard = (await LoyaltyCard.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: Card,
	                as: 'card',
	                include: [
	                    {
	                        model: CardTemplate,
	                        as: 'cardTemplate',
	                    },
	                ],
	            },
	        ],
	    })) as LoyaltyCard & { card: Card & { cardTemplate: CardTemplate } };
	    if (!loyaltyCard) throw new HttpError(404, 'Card not found');
	
	    // find the gift
	    const gift = await LoyaltyGift.findOne({
	        where: {
	            id: giftId,
	        },
	    });
	    if (!gift) throw new HttpError(404, 'Gift not found');
	    const isGiftLimited = gift.limitedAmount !== null;
	
	    // check if the gift in stock
	    if (isGiftLimited && gift.limitedAmount <= 0) throw new HttpError(400, 'Gift out of stock');
	
	    // check if the user has enough points
	    if (loyaltyCard.points < gift.priceNPoints) throw new HttpError(400, 'Not enough points');
	
	    // subtract points
	    loyaltyCard.points -= gift.priceNPoints;
	
	    loyaltyCard.redeemedLoyaltyGifts = [
	        ...(loyaltyCard.redeemedLoyaltyGifts || []),
	        {
	            id: gift.id,
	            name: gift.name,
	            redeemedAt: new Date(),
	        },
	    ];
	
	    // subtract gift from stock if limited
	    if (isGiftLimited) {
	        gift.limitedAmount -= 1;
	        await gift.save();
	    }
	
	    // log activity
	    await Activity.create({
	        businessId: loyaltyCard.card.cardTemplate.businessId,
	        message: `Card ${loyaltyCard.id} scanned, gift ${gift.name} redeemed`,
	        types: [ActivityType.SCAN_CARD, ActivityType.LOYALTY_GIFT_REDEEM],
	        relatedId: loyaltyCard.id,
	        relatedType: 'card',
	        userId: user.id,
	    });
	
	    const savedLoayltyCard = await loyaltyCard.save();
	    await generatePassFromTemplate(cardId, savedLoayltyCard.card.templateId);
	    await sendUpdatePassNotification(savedLoayltyCard.card.pushToken);
	
	    return savedLoayltyCard;
	};
	
	export const registerDevice = async ({
	    serialNumber,
	    pushToken,
	    deviceLibraryIdentifier,
	}: {
	    serialNumber: number;
	    pushToken: string;
	    deviceLibraryIdentifier: string;
	}) => {
	    console.log('registerDevice');
	
	    // find card
	    const card = await Card.findOne({
	        where: {
	            id: serialNumber,
	        },
	    });
	    if (!card) throw new HttpError(404, 'Card not found');
	
	    // update deviceLibraryIdentifier
	    card.deviceLibraryIdentifier = deviceLibraryIdentifier;
	
	    // update pushToken
	    card.pushToken = pushToken;
	
	    await card.save();
	
	    console.log('registerDevice Success');
	    return true;
	};
	
	export const unregisterDevice = async (props: {
	    deviceLibraryIdentifier: string;
	    passTypeIdentifier: string;
	    serialNumber: number;
	}) => {
	    console.log('unregisterDevice');
	
	    // find card
	    const card = await Card.findOne({
	        where: {
	            id: props.serialNumber,
	        },
	    });
	    if (!card) throw new HttpError(404, 'Card not found');
	
	    // update pushToken
	    card.pushToken = null;
	    await card.save();
	
	    console.log('unregisterDevice Success');
	    return true;
	};
	
	export const getSerialNumbers = async (props: { deviceLibraryIdentifier: string }) => {
	    console.log('getSerialNumbers');
	
	    // find cards
	    const cards = await Card.findAll({
	        where: {
	            deviceLibraryIdentifier: props.deviceLibraryIdentifier,
	        },
	        attributes: ['id', 'updatedAt', 'createdAt'],
	    });
	
	    const ids = cards.map((card) => card.id.toString());
	    const lastUpdated = cards.length > 0 ? cards[0].updatedAt || cards[0].createdAt : new Date();
	    console.log(ids);
	    console.log('getSerialNumbers Success');
	    const out = {
	        serialNumbers: ids,
	        lastUpdated,
	    };
	    console.log(out);
	    return out;
	};
	export const sendUpdatedPass = async (props: { passTypeIdentifier: string; serialNumber: number }) => {
	    console.log('sendUpdatedPass');
	
	    // find card
	    const card = await Card.findOne({
	        where: {
	            id: props.serialNumber,
	        },
	        include: [
	            {
	                model: LoyaltyCard,
	                as: 'loyaltyCard',
	                required: false,
	            },
	        ],
	    });
	    if (!card) throw new HttpError(404, 'Card not found');
	
	    // if it is a loyalty card, and changed from cann't scan to can scan based on the activities, generate a new pass
	    if (card.loyaltyCanScan) {
	        const oldCanScan = card.canScan;
	        const canScanNow = await card.loyaltyCanScan();
	        if (oldCanScan === false && canScanNow === true) {
	            await generatePassFromTemplate(card.id, card.templateId);
	        }
	    }
	
	    // load the pkpass file
	    const pkpassBuffer = (await getFile(card.s3Key))?.Body as Buffer;
	
	    // send the pkpass file
	    console.log('sendUpdatedPass Success');
	    return pkpassBuffer;
	};
	
	export function loyaltyUpdatePoints(cardId: number, points: number, user: User) {
	    if (!Number.isInteger(points)) throw new HttpError(400, 'Points must be an integer');
	    if (points < 0) throw new HttpError(400, 'Points cannot be negative');
	
	    return LoyaltyCard.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: Card,
	                as: 'card',
	                required: true,
	                include: [
	                    {
	                        model: CardTemplate,
	                        as: 'cardTemplate',
	                        where: {
	                            businessId: user.businesses.map((b) => b.id),
	                        },
	                        required: true,
	                    },
	                ],
	            },
	        ],
	    }).then(async (loyaltyCard) => {
	        if (!loyaltyCard) throw new HttpError(404, 'Card not found');
	
	        // update points
	        loyaltyCard.points = points;
	
	        // update the pass
	        await generatePassFromTemplate(cardId, loyaltyCard.card.templateId);
	        await sendUpdatePassNotification(loyaltyCard.card.pushToken);
	
	        return loyaltyCard.save();
	    });
	}
	
	async function validateAndChooseSeat(event: Event, seat: string) {
	    // extrct the alhabets from the seat
	    const seatColumn = seat.replace(/\d/g, '').toUpperCase();
	
	    // extract the numbers from the seat
	    const seatRow = parseInt(seat.replace(/\D/g, ''));
	
	    // turn seat column into colum index (A=1) (AA=27)
	    const seatColumnIndex = seatColumn
	        .split('')
	        .map((c, i) => c.charCodeAt(0) - 65 + 26 * i)
	        .reduce((a, b) => a + b, 0);
	
	    // turn seat row into row index
	    const seatRowIndex = seatRow - 1;
	
	    const room = event.room;
	    // check if the seat is in the event
	    if (
	        seatColumnIndex < 0 ||
	        seatColumnIndex >= room[0].length ||
	        seatRowIndex < 0 ||
	        seatRowIndex >= event.room.length
	    )
	        throw new HttpError(400, 'Seat not found');
	
	    // check if the seat is taken
	    if (room[seatRowIndex][seatColumnIndex] !== SeatType.AVAILABILE_SEAT) throw new HttpError(400, 'Seat unavailable');
	
	    // update room
	    room[seatRowIndex][seatColumnIndex] = SeatType.UNAVAILABLE_SEAT;
	    console.log(room);
	    
	    event.room = room;
	    await Event.update(
	        {
	            room,
	        },
	        {
	            where: {
	                id: event.id,
	            },
	        },
	    );
	
	    return true;
	}
	
	export async function scanTicket(cardId: number, user: User) {
	    // find card
	    const eventTicket = await EventCard.findOne({
	        where: {
	            id: cardId,
	        },
	        include: [
	            {
	                model: EventTicketTemplate,
	                as: 'eventTicketTemplate',
	                required: true,
	                include: [
	                    {
	                        model: Event,
	                        as: 'event',
	                        required: true,
	                    },
	                ],
	            },
	        ],
	    });
	
	    // check if expired
	    if (await eventTicket.isExpired()) throw new HttpError(400, 'Ticket expired');
	
	    // check if used
	    if (eventTicket.used) throw new HttpError(400, 'Ticket already used');
	
	    // mark as used
	    eventTicket.used = true;
	
	    // return response
	    return eventTicket.save();
	}
```

modules/events/controllers/events.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import * as eventServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { CreateEventDto } from '../dto/create-event';
	import { UpdateEventDto } from '../dto/update-event';
	
	export const EventsController: ICRUDController = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const body: CreateEventDto = req.body;
	        const buinessId = Number(req.params.businessId);
	
	        eventServices
	            .createEvent(body, buinessId)
	            .then((event) => res.status(201).json(event))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const eventId = Number(req.params.id);
	
	        eventServices
	            .findOneEventById(eventId)
	            .then((event) => res.json(event))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	        const businessId = Number(req.params.businessId);
	
	        eventServices
	            .findAllEvents({ limit, offset, businessId })
	            .then((event) => res.json(event))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: Request, res: Response, next: NextFunction): void {
	        const eventId = Number(req.params.id);
	        const body: UpdateEventDto = req.body;
	
	        eventServices
	            .updateEventById(eventId, body)
	            .then((event) => res.json(event))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const eventId = Number(req.params.id);
	
	        eventServices
	            .deleteEventById(eventId)
	            .then((event) => res.json(event))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	};
```

modules/events/dto/create-event.ts:
```
	import {
	    IsArray,
	    IsDateString,
	    IsIn,
	    IsNotEmpty,
	    IsNumber,
	    IsOptional,
	    IsString,
	    Min,
	    Validate,
	} from 'class-validator';
	import { SeatType } from '../models/event.model';
	
	export class CreateEventDto {
	    // title
	    @IsNotEmpty()
	    @IsString()
	    title: string;
	
	    // description
	    @IsOptional()
	    @IsString()
	    description?: string;
	
	    // startDate
	    @IsNotEmpty()
	    @IsDateString()
	    startDate: string;
	
	    // endDate
	    @IsNotEmpty()
	    @IsDateString()
	    endDate: string;
	
	    // limitedAmount
	    @IsOptional()
	    @IsNumber()
	    @Min(1)
	    limitedAmount?: number;
	
	    // room
	    @IsOptional()
	    @IsArray({each: true})
	    room?: SeatType[][];
	}
```

modules/events/dto/update-event.ts:
```
	import { PartialType } from '@nestjs/mapped-types';
	import { CreateEventDto } from './create-event';
	
	export class UpdateEventDto extends PartialType(CreateEventDto) {}
```

modules/events/models/event.model.ts:
```
	import { DataTypes, Model, Sequelize } from 'sequelize';
	import { LoyaltyCardTemplate } from '../../card-templates/models/loyalty-card-template.model';
	import { Activity } from '../../businesses/models/activity.model';
	import { Business } from '../../businesses/models/business.model';
	import { EventTicketTemplate } from '../../card-templates/models/event-ticket-template.model';
	
	export enum SeatType {
	    NONE = 0,
	    THEATER = 1,
	    AVAILABILE_SEAT = 2,
	    UNAVAILABLE_SEAT = 3,
	}
	
	export class Event extends Model {
	    public declare id: number;
	    public title: string;
	    public description: string;
	    public startDate: Date;
	    public endDate: Date;
	    public limitedAmount?: number;
	    public businessId!: number;
	    public room?: SeatType[][];
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    Event.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	                autoIncrement: true,
	            },
	            title: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            description: {
	                type: DataTypes.STRING,
	                allowNull: true,
	            },
	            startDate: {
	                type: DataTypes.DATE,
	                allowNull: false,
	            },
	            endDate: {
	                type: DataTypes.DATE,
	                allowNull: false,
	            },
	            limitedAmount: {
	                type: DataTypes.INTEGER,
	                allowNull: true,
	            },
	            businessId: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            room: {
	                type: DataTypes.ARRAY(DataTypes.ARRAY(DataTypes.INTEGER)),
	                allowNull: true,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'events',
	        },
	    );
	
	export const associate = () => {
	    // Event | Activity
	    Event.hasMany(Activity, {
	        foreignKey: 'relatedId',
	        as: 'activities',
	        constraints: false,
	        scope: {
	            relatedType: 'event',
	        },
	    });
	
	    // Event | Business
	    Event.belongsTo(Business, {
	        foreignKey: 'businessId',
	        as: 'business',
	    });
	
	    // Event | Event Ticket Template
	    Event.hasMany(EventTicketTemplate, {
	        foreignKey: 'eventId',
	        as: 'eventTicketTemplates',
	    });
	};
```

modules/events/services/index.ts:
```
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { Branch } from '../../branches/models/branch.model';
	import { CreateEventDto } from '../dto/create-event';
	import { UpdateEventDto } from '../dto/update-event';
	import { Event, SeatType } from '../models/event.model';
	
	export const createEvent = (createEventDto: CreateEventDto, businessId: number): Promise<Event> => {
	    // validate startDate and endDate
	    if (new Date(createEventDto.startDate) > new Date(createEventDto.endDate))
	        throw new HttpError(400, 'startDate must be before endDate');
	
	    // validate room if it exists
	    if (createEventDto.room) {
	        const room = createEventDto.room;
	
	        
	        // validate that all the rows have the same length
	        const rowLength = room[0].length;
	        if (!room.every((row) => row.length === rowLength))
	        throw new HttpError(400, 'room must be a matrix with equal row lengths');
	        
	        // validate values
	        const allowedSeatTypes = [
	            SeatType.NONE,
	            SeatType.THEATER,
	            SeatType.AVAILABILE_SEAT,
	        ]
	        if (!room.every((row) => row.every((seat) => allowedSeatTypes.includes(seat))))
	            throw new HttpError(400, `allowed seat types are ${allowedSeatTypes.join(', ')}`); 
	
	        // validate number of available seats with the limitedAmount if it exists
	        const availableSeats = room.reduce(
	            (acc, row) => acc + row.filter((seat) => seat === SeatType.AVAILABILE_SEAT).length,
	            0,
	        );
	
	        if (createEventDto.limitedAmount && availableSeats < createEventDto.limitedAmount)
	            throw new HttpError(400, 'limitedAmount must be less than or equal to the number of available seats');
	
	        // if the limitedAmount is not provided, set it to the number of available seats
	        if (!createEventDto.limitedAmount) createEventDto.limitedAmount = availableSeats;
	    }
	
	    const event = new Event({ ...createEventDto, businessId: businessId });
	    return event.save();
	};
	
	// only select users who share a event with the logged in user
	export const findAllEvents = async ({
	    limit = 10,
	    offset = 0,
	    businessId,
	}: {
	    limit: number;
	    offset: number;
	    businessId: number;
	}) => {
	    return Event.findAndCountAll({
	        where: {
	            businessId,
	        },
	        limit,
	        offset,
	    });
	};
	
	export const findOneEventById = (eventId: number): Promise<Event> => {
	    return Event.findOne({
	        where: {
	            id: eventId,
	        },
	        include: [
	            {
	                model: Branch,
	                as: 'branches',
	            },
	        ],
	    });
	};
	
	export const updateEventById = async (eventId: number, updateEventDto: UpdateEventDto): Promise<Event> => {
	    const event = await findOneEventById(eventId);
	    if (!event) throw new HttpError(404, 'Event not found');
	
	    if (!updateEventDto.startDate) updateEventDto.startDate = event.startDate as any;
	    if (!updateEventDto.endDate) updateEventDto.endDate = event.endDate as any;
	    if (!updateEventDto.room) updateEventDto.room = event.room as any;
	    if (!updateEventDto.limitedAmount) updateEventDto.limitedAmount = event.limitedAmount as any;
	
	    // validate startDate and endDate
	    if (new Date(updateEventDto.startDate) > new Date(updateEventDto.endDate))
	        throw new HttpError(400, 'startDate must be before endDate');
	
	    // validate room if it exists
	    if (updateEventDto.room) {
	        const room = updateEventDto.room;
	
	        // validate that all the rows have the same length
	        const rowLength = room[0].length;
	        if (!room.every((row) => row.length === rowLength))
	            throw new HttpError(400, 'room must be a matrix with equal row lengths');
	
	        // validate number of available seats with the limitedAmount if it exists
	        const availableSeats = room.reduce(
	            (acc, row) => acc + row.filter((seat) => seat === SeatType.AVAILABILE_SEAT).length,
	            0,
	        );
	
	        if (updateEventDto.limitedAmount && availableSeats < updateEventDto.limitedAmount)
	            throw new HttpError(400, 'limitedAmount must be less than or equal to the number of available seats');
	
	        // if the limitedAmount is not provided, set it to the number of available seats
	        if (!updateEventDto.limitedAmount) updateEventDto.limitedAmount = availableSeats;
	    }
	
	    return event.update(updateEventDto);
	};
	
	export const deleteEventById = async (eventId: number) => {
	    const event = await findOneEventById(eventId);
	    if (!event) throw new HttpError(404, 'Event not found');
	
	    return event.destroy().then(() => ({ message: 'Event deleted successfully' }));
	};
```

modules/file-upload/controllers/file-upload.controller.ts:
```
	import { NextFunction, Response } from 'express';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import * as fileUploadService from '../services/file-upload.service';
	import { UploadedFile } from 'express-fileupload';
	
	export const FileUploadController = {
	    create: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const file = req.files.file as UploadedFile;
	        if (!file) {
	            return next(new Error('No file uploaded'));
	        }
	
	        fileUploadService
	            .uploadFile(file, req.user)
	            .then((file) => {
	                res.json(file);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    list: function (req: RequestMod, res: Response, next: NextFunction): void {
	        fileUploadService
	            .listFiles(req.user)
	            .then((files) => {
	                res.json(files);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getFile: function (req: RequestMod, res: Response, next: NextFunction): void {
	        fileUploadService
	            .getFile(Number(req.params.id), req.user)
	            .then((file) => {
	                res.json(file);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    delete: function (req: RequestMod, res: Response, next: NextFunction): void {
	        fileUploadService
	            .deleteFile(Number(req.params.id), req.user)
	            .then((file) => {
	                res.json(file);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	};
```

modules/file-upload/models/file.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { User } from '../../users/models/user.model';
	
	export class File extends Model {
	    public declare id: number;
	    public createdBy!: number;
	    public name!: string;
	    public url!: string;
	    public mimeType!: string;
	    public key!: string;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	}
	
	export const init = (sequelize: Sequelize) =>
	    File.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                primaryKey: true,
	                autoIncrement: true,
	            },
	            createdBy: {
	                type: DataTypes.INTEGER,
	                allowNull: false,
	            },
	            name: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            url: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            mimeType: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            key: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'files',
	        },
	    );
	
	export const associate = () => {
	    // User | File
	    File.belongsTo(User, {
	        foreignKey: 'createdBy',
	        as: 'creator',
	    });
	};
```

modules/file-upload/services/file-upload.service.ts:
```
	import { UploadedFile } from 'express-fileupload';
	import { HttpError } from '../../../common';
	import { User } from '../../users/models/user.model';
	import path from 'path';
	import fs from 'fs';
	import { File } from '../models/file.model';
	import * as s3 from '../../aws/s3';
	
	export const uploadFile = async (file: UploadedFile, user: User) => {
	    await validateUploadFile(file);
	
	    const uploadFolderParent = 'uploads';
	    let uploadFolder: string = `${uploadFolderParent}/${user.id}`;
	
	    // generate a random file name
	    const fileName = `${new Date().getTime()}-${user.id}-${file.name}`;
	
	    // create the upload folder if not exist
	    const res = await s3.uploadFile(
	        {
	            name: fileName,
	            data: file.data,
	        },
	        uploadFolder,
	    );
	
	    // save the file to the database
	    const fileCreated = await File.create({
	        createdBy: user.id,
	        name: file.name,
	        url: res.Location,
	        mimeType: file.mimetype,
	        key: res.Key,
	    });
	
	    return fileCreated;
	};
	
	export const listFiles = async (user: User) => {
	    const files = await File.findAll({
	        where: {
	            createdBy: user.id,
	        },
	    });
	
	    return files;
	};
	
	export const getFile = async (id: number, user: User) => {
	    const file = await File.findOne({
	        where: {
	            id,
	            createdBy: user.id,
	        },
	    });
	
	    if (!file) throw new HttpError(404, 'File not found');
	
	    return file;
	};
	
	export const deleteFile = async (id: number, user: User) => {
	    const file = await File.findOne({
	        where: {
	            id,
	            createdBy: user.id,
	        },
	    });
	
	    if (!file) throw new HttpError(404, 'File not found');
	
	    // remove the file from the uploads folder
	    await s3.deleteFile(file.key);
	
	    // remove the file from the database
	    await file.destroy();
	
	    return file;
	};
	
	const validateUploadFile = async (file: UploadedFile) => {
	    // only accept image file [png, jpg, jpeg] from the mime type
	    const allowedMimeTypes = ['image/png', 'image/jpg', 'image/jpeg'];
	    if (!allowedMimeTypes.includes(file.mimetype)) {
	        throw new HttpError(400, 'Invalid file type, only [png, jpg, jpeg] are allowed');
	    }
	
	    // only accept file size <= 5MB
	    const allowedFileSize = 5 * 1024 * 1024;
	    if (file.size > allowedFileSize) {
	        throw new HttpError(400, 'File size is too large, only <= 5MB are allowed');
	    }
	
	    return file;
	};
```

modules/notifications/controllers/notifications.controller.ts:
```
	import { NextFunction, Response } from 'express';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import * as notificationsService from '../services/notifications.service';
	import { CreateCardNotificationDto } from '../dto/create-notification';
	
	export const NotificationsController = {
	    createCardNotification: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const body: CreateCardNotificationDto = req.body;
	
	        notificationsService
	            .sendCardNotification(body, req.user)
	            .then((file) => {
	                res.json(file);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	};
```

modules/notifications/dto/create-notification.ts:
```
	import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';
	
	export class CreateCardNotificationDto {
	    // card id
	    @IsNotEmpty()
	    @IsNumber()
	    cardId: number;
	
	    // alert
	    @IsNotEmpty()
	    @IsString()
	    alert: string;
	}
```

modules/notifications/services/apn.service.ts:
```
	import { Notification, Provider, ProviderOptions } from 'apn';
	
	var options: ProviderOptions = {
	    cert: `${__dirname}/../../../certs/signerCert.pem`,
	    key: `${__dirname}/../../../certs/signerKey.key`,
	    production: true,
	};
	
	export const apnProvider = new Provider(options);
	
	export const sendNotification = async (
	    notificationProps: { alert: string } & Partial<Notification>,
	    recipients: string | string[],
	) => {
	    try {
	        const notification = new Notification();
	        notification.alert = notificationProps.alert;
	        notification.topic = 'com.zajil.passes';
	        const result = await apnProvider.send(notification, recipients);
	        console.log(JSON.stringify(result, null, 2));
	    } catch (error) {
	        console.log(error);
	    }
	};
	
	export const sendUpdatePassNotification = async (deviceToken: string) => {
	    const notification = new Notification();
	    notification.topic = 'com.zajil.passes';
	
	    try {
	        const result = await apnProvider.send(notification, deviceToken).catch((error) => {
	            throw new Error(error);
	        });
	        console.log(JSON.stringify(result || '', null, 2));
	    } catch (error) {
	        console.log(error);
	    }
	};
```

modules/notifications/services/notifications.service.ts:
```
	import { HttpError } from '../../../common';
	import { Business } from '../../businesses/models/business.model';
	import { CardTemplate } from '../../card-templates/models/card-template.model';
	import { Card } from '../../cards/models/card.model';
	import { User } from '../../users/models/user.model';
	import { CreateCardNotificationDto } from '../dto/create-notification';
	import { sendNotification } from './apn.service';
	
	export const sendCardNotification = async (CreateCardNotificationDto: CreateCardNotificationDto, user: User) => {
	    // find the card
	    const card = (await Card.findOne({
	        where: {
	            id: CreateCardNotificationDto.cardId,
	        },
	        include: [
	            {
	                model: CardTemplate,
	                as: 'cardTemplate',
	                include: [
	                    {
	                        model: Business,
	                        as: 'business',
	                    },
	                ],
	            },
	        ],
	    })) as Card & { cardTemplate: CardTemplate & { business: Business } };
	    if (!card) {
	        throw new HttpError(404, 'Card not found');
	    }
	
	    // check if the user is an owner of the business issuing the card
	    const bussinessUserOwns = user.businesses.map((business) => business.id);
	    const businessUserEmployeeOf = user.employedAt.map((business) => business.id);
	    if (![...bussinessUserOwns, ...businessUserEmployeeOf].includes(card.cardTemplate.business.id))
	        throw new HttpError(403, 'User is not authorized to send notifications for this card');
	
	    // check if the card is registered
	    if (!card.deviceLibraryIdentifier) throw new HttpError(400, 'Card is not registered for notifications');
	
	    // send notification
	    await sendNotification(
	        {
	            alert: CreateCardNotificationDto.alert,
	        },
	        card.pushToken,
	    ).catch((err) => {
	        console.error(err);
	        throw new HttpError(500, err);
	    });
	
	    return {
	        message: 'Notification sent',
	    };
	};
```

modules/statistics/controllers/statistics.controller.ts:
```
	import { NextFunction, Response } from 'express';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import * as statisticsServices from '../services/statistics.service';
	import { GetCardsQueryDto } from '../dto/get-cards.query.dto';
	import { GetCardsTotalQueryDto } from '../dto/get-cards-total.query.dto';
	import { GetCardsChartQueryDto } from '../dto/get-cards-chart.query.dto';
	import { GetActivitiesQueryDto } from '../dto/get-activities.query.dto';
	
	export const StatisticsController = {
	    getCardStatistics: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { limit, type, businessId } = req.query as GetCardsQueryDto;
	
	        statisticsServices
	            .getCardStatistics(req.user, limit, type, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getCardsTotal: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { businessId } = req.query as GetCardsTotalQueryDto;
	
	        statisticsServices
	            .getCardsTotal(req.user, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getCardsChart: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { businessId, startDate, endDate, nPoints } = req.query as any;
	
	        statisticsServices
	            .getCardsChart(req.user, startDate, endDate, nPoints, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getCardsRewardsRedeemedChart: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { businessId, startDate, endDate, nPoints } = req.query as any;
	
	        statisticsServices
	            .getCardsRewardsRedeemedChart(req.user, startDate, endDate, nPoints, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getActivities: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { businessId, limit } = req.query as GetActivitiesQueryDto;
	
	        statisticsServices
	            .getActivities(req.user, limit, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    },
	
	    getActivitiesChart: function (req: RequestMod, res: Response, next: NextFunction): void {
	        // get query params
	        const { businessId, startDate, endDate, nPoints } = req.query as any;
	
	        statisticsServices
	            .getActivitiesChart(req.user, startDate, endDate, nPoints, businessId)
	            .then((o) => {
	                res.json(o);
	            })
	            .catch((err) => {
	                next(err);
	            });
	    }
	};
```

modules/statistics/dto/get-activities-chart.query.dto.ts:
```
	import { Type } from 'class-transformer';
	import { IsDateString, IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from 'class-validator';
	
	export class GetActivitiesChartQueryDto {
	    @IsDateString()
	    startDate: string;
	
	    @IsDateString()
	    endDate: string;
	
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    nPoints: number;
	
	    @IsOptional()
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    businessId?: number;
	}
```

modules/statistics/dto/get-activities.query.dto.ts:
```
	import { Type } from "class-transformer";
	import { IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from "class-validator";
	
	export class GetActivitiesQueryDto {
	    @IsOptional()
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    limit?: number = 10;
	
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Type(() => Number)
	    businessId?: number;
	}```

modules/statistics/dto/get-cards-chart.query.dto.ts:
```
	import { Type } from 'class-transformer';
	import { IsDateString, IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from 'class-validator';
	
	export class GetCardsChartQueryDto {
	    @IsDateString()
	    startDate: string;
	
	    @IsDateString()
	    endDate: string;
	
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    nPoints: number;
	
	    @IsOptional()
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    businessId?: number;
	}
```

modules/statistics/dto/get-cards-rewards-redeemed-chart.query.dto.ts:
```
	import { Type } from 'class-transformer';
	import { IsDateString, IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from 'class-validator';
	
	export class GetCardsRewardsRedeemedChartQueryDto {
	    @IsDateString()
	    startDate: string;
	
	    @IsDateString()
	    endDate: string;
	
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    nPoints: number;
	
	    @IsOptional()
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    businessId?: number;
	}
```

modules/statistics/dto/get-cards-total.query.dto.ts:
```
	import { Type } from "class-transformer";
	import { IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from "class-validator";
	
	export class GetCardsTotalQueryDto {
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Type(() => Number)
	    businessId?: number;
	}```

modules/statistics/dto/get-cards.query.dto.ts:
```
	import { Type } from "class-transformer";
	import { IsIn, IsNotEmpty, IsNumber, IsOptional, IsPositive } from "class-validator";
	
	export class GetCardsQueryDto {
	    @IsOptional()
	    @IsNumber()
	    @IsPositive()
	    @Type(() => Number)
	    limit?: number = 10;
	
	    @IsOptional()
	    @IsNotEmpty()
	    @IsIn(["active", "new"])
	    type?: string = "new";
	
	    @IsOptional()
	    @IsNotEmpty()
	    @IsNumber()
	    @Type(() => Number)
	    businessId?: number;
	}```

modules/statistics/services/statistics.service.ts:
```
	const moment = require('moment');
	import { HttpError } from '../../../common';
	import { Activity, ActivityType } from '../../businesses/models/activity.model';
	import { Business } from '../../businesses/models/business.model';
	import { CardTemplate } from '../../card-templates/models/card-template.model';
	import { Card } from '../../cards/models/card.model';
	import { User } from '../../users/models/user.model';
	import { Op } from 'sequelize';
	
	export const getCardStatistics = async (
	    user: User,
	    limit: number,
	    type: string,
	    businessId?: number,
	): Promise<Card[]> => {
	    let cards: Card[] = [];
	
	    switch (type) {
	        case 'new': // default
	            cards = await getNewCards(user, limit, businessId);
	            break;
	        case 'active':
	            cards = await getActiveCards(user, limit, businessId);
	            break;
	        default:
	            throw new Error('Invalid type');
	    }
	
	    return cards;
	};
	
	// the newest {limit} cards across all businesses or a specific business
	const getNewCards = async (user: User, limit: number, businessId?: number): Promise<Card[]> => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        return await Card.findAll({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: businessId,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	            ],
	            order: [['id', 'DESC']],
	            limit,
	        });
	    } else {
	        return await Card.findAll({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: userBusinesses,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	            ],
	            order: [['id', 'DESC']],
	            limit,
	        });
	    }
	};
	
	// get {limit} active cards across all businesses or a specific business
	// an active card, is a card that has user at least once in the last 30 days
	const getActiveCards = async (user: User, limit: number, businessId?: number): Promise<Card[]> => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        return await Card.findAll({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    required: true,
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: businessId,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	                {
	                    model: Activity,
	                    as: 'activities',
	                    where: {
	                        createdAt: {
	                            [Op.gte]: moment().subtract(30, 'days').toDate(),
	                        },
	                    },
	                    required: true,
	                },
	            ],
	            limit,
	        });
	    } else {
	        return await Card.findAll({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    required: true,
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: userBusinesses,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	                {
	                    model: Activity,
	                    as: 'activities',
	                    where: {
	                        createdAt: {
	                            [Op.gte]: moment().subtract(30, 'days').toDate(),
	                        },
	                    },
	                    required: true,
	                },
	            ],
	            limit,
	        });
	    }
	};
	
	export const getCardsTotal = async (user: User, businessId?: number) => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        return await Card.count({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    required: true,
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: businessId,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	            ],
	        });
	    } else {
	        return await Card.count({
	            include: [
	                {
	                    model: CardTemplate,
	                    as: 'cardTemplate',
	                    required: true,
	                    include: [
	                        {
	                            model: Business,
	                            as: 'business',
	                            where: {
	                                id: userBusinesses,
	                            },
	                            required: true,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	};
	
	// finds cards created between startDate and endDate
	// partitions the time interval into nPoints
	// for each point, it counts the number of cards created
	// returns an array of numbers of length nPoints
	export const getCardsChart = async (
	    user: User,
	    startDate: string,
	    endDate: string,
	    nPoints: number,
	    businessId?: number,
	) => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	    let businessToUse: number[] = [];
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        businessToUse = [businessId];
	    } else {
	        businessToUse = userBusinesses;
	    }
	
	    // find cards created between startDate and endDate
	    const cards = await Card.findAll({
	        include: [
	            {
	                model: CardTemplate,
	                as: 'cardTemplate',
	                include: [
	                    {
	                        model: Business,
	                        as: 'business',
	                        where: {
	                            id: businessToUse,
	                        },
	                        required: true,
	                    },
	                ],
	                required: true,
	            },
	        ],
	        where: {
	            createdAt: {
	                [Op.between]: [startDate, endDate],
	            },
	        },
	    });
	
	    // partitions the time interval into nPoints
	    const interval = moment(endDate).diff(moment(startDate), 'milliseconds');
	    const intervalPerPoint = interval / nPoints;
	
	    // for each point, it counts the number of cards created
	    // returns an array of numbers of length nPoints
	    const points = [];
	    for (let i = 0; i < nPoints; i++) {
	        const pointStart = moment(startDate).add(i * intervalPerPoint, 'milliseconds');
	        const pointEnd = moment(startDate).add((i + 1) * intervalPerPoint, 'milliseconds');
	
	        const cardsInPoint = cards.filter((card) => {
	            return moment(card.createdAt).isBetween(pointStart, pointEnd);
	        });
	
	        points.push(cardsInPoint.length);
	    }
	
	    return points;
	};
	
	export const getCardsRewardsRedeemedChart = async (
	    user: User,
	    startDate: string,
	    endDate: string,
	    nPoints: number,
	    businessId?: number,
	) => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	    let businessToUse: number[] = [];
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        businessToUse = [businessId];
	    } else {
	        businessToUse = userBusinesses;
	    }
	
	    // find rewards redeemed activity between startDate and endDate
	    // look for messages of this format:  message: `Card ${loyaltyCard.id} scanned, gift ${gift.name} redeemed`,
	    const activities = await Activity.findAll({
	        where: {
	            createdAt: {
	                [Op.between]: [startDate, endDate],
	            },
	            type: {
	                [Op.contains]: [ActivityType.SCAN_CARD, ActivityType.LOYALTY_GIFT_REDEEM],
	            },
	        },
	    });
	
	    // partitions the time interval into nPoints
	    const interval = moment(endDate).diff(moment(startDate), 'milliseconds');
	    const intervalPerPoint = interval / nPoints;
	
	    // for each point, it counts the number of cards created
	    // returns an array of numbers of length nPoints
	    const points = [];
	    for (let i = 0; i < nPoints; i++) {
	        const pointStart = moment(startDate).add(i * intervalPerPoint, 'milliseconds');
	        const pointEnd = moment(startDate).add((i + 1) * intervalPerPoint, 'milliseconds');
	
	        const activitiesInPoint = activities.filter((activity) => {
	            return moment(activity.createdAt).isBetween(pointStart, pointEnd);
	        });
	
	        points.push(activitiesInPoint.length);
	    }
	
	    return points;
	};
	
	export const getActivities = async (user: User, limit: number, businessId?: number) => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	    const businessToUse = businessId ? [businessId] : userBusinesses;
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	    }
	
	    return await Activity.findAll({
	        include: [
	            {
	                model: Card,
	                as: 'card',
	                include: [
	                    {
	                        model: CardTemplate,
	                        as: 'cardTemplate',
	                        include: [
	                            {
	                                model: Business,
	                                as: 'business',
	                            },
	                        ],
	                    },
	                ],
	            },
	        ],
	        where: {
	            businessId: businessToUse,
	        },
	        order: [['id', 'DESC']],
	        limit,
	    });
	};
	
	export const getActivitiesChart = async (
	    user: User,
	    startDate: string,
	    endDate: string,
	    nPoints: number,
	    businessId?: number,
	) => {
	    const userBusinesses = user.businesses.map((business) => business.id);
	    let businessToUse: number[] = [];
	
	    if (businessId) {
	        // check if user has access to this business
	        if (!userBusinesses.includes(businessId))
	            throw new HttpError(403, 'Forbidden, user does not have access to this business');
	
	        businessToUse = [businessId];
	    } else {
	        businessToUse = userBusinesses;
	    }
	
	    // find activities between startDate and endDate
	    const activities = await Activity.findAll({
	        where: {
	            createdAt: {
	                [Op.between]: [startDate, endDate],
	            },
	            businessId: businessToUse,
	        },
	    });
	
	    // partitions the time interval into nPoints
	    const interval = moment(endDate).diff(moment(startDate), 'milliseconds');
	    const intervalPerPoint = interval / nPoints;
	
	    // for each point, it counts the number of cards created
	    // returns an array of numbers of length nPoints
	    const points = [];
	    for (let i = 0; i < nPoints; i++) {
	        const pointStart = moment(startDate).add(i * intervalPerPoint, 'milliseconds');
	        const pointEnd = moment(startDate).add((i + 1) * intervalPerPoint, 'milliseconds');
	
	        const activitiesInPoint = activities.filter((activity) => {
	            return moment(activity.createdAt).isBetween(pointStart, pointEnd);
	        });
	
	        points.push(activitiesInPoint.length);
	    }
	
	    return points;
	};
```

modules/users/controllers/Users.ts:
```
	import { NextFunction, Request, Response } from 'express';
	import { CreateUserDto } from '../dto/create-user';
	import * as usersServices from '../services';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import ICRUDController from '../../../common/interfaces/crud.controller';
	import { UpdateUserDto } from '../dto/update-user';
	
	export const UsersController: ICRUDController & {
	    activateAccount: (req: Request, res: Response, next: NextFunction) => void;
	    requestAccountActivation: (req: Request, res: Response, next: NextFunction) => void;
	} = {
	    create: function (req: Request, res: Response, next: NextFunction): void {
	        const body: CreateUserDto = req.body;
	        usersServices
	            .createUser(body)
	            .then((user) => res.status(201).json(user))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    getOne: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const userId = Number(req.params.id);
	        console.log('userId', userId);
	
	        usersServices
	            .findOneUserById(userId)
	            .then((user) => res.json(user))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(404, err.message));
	            });
	    },
	    getAll: function (req: RequestMod, res: Response, next: NextFunction): void {
	        const limit = Number(req.query.limit) || 10;
	        const offset = Number(req.query.offset) || 0;
	
	        usersServices
	            .findAllUsers({ limit, offset, req })
	            .then((users) => res.json(users))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    update: function (req: Request, res: Response, next: NextFunction): void {
	        const userId = Number(req.params.id);
	        const body: UpdateUserDto = req.body;
	
	        usersServices
	            .updateUserById(userId, body)
	            .then((user) => res.json(user))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	    delete: function (req: Request, res: Response, next: NextFunction): void {
	        const userId = Number(req.params.id);
	
	        usersServices
	            .deleteUserById(userId)
	            .then((user) => res.json(user))
	            .catch((err) => {
	                console.error(err);
	                if (err instanceof HttpError) next(err);
	                else next(new HttpError(500, err.message));
	            });
	    },
	
	    activateAccount: function (req: Request, res: Response, next: NextFunction): void {
	        const token = req.params.token;
	
	        usersServices
	            .activateAccount(token)
	            .then((user) => res.json(user))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	
	    requestAccountActivation: function (req: RequestMod, res: Response, next: NextFunction): void {
	        usersServices
	            .requestAccountActivation(req.user)
	            .then((user) => res.json(user))
	            .catch((err) => {
	                console.error(err);
	                next(new HttpError(500, err.message));
	            });
	    },
	};
```

modules/users/dto/create-user.ts:
```
	import { IsArray, IsEmail, IsEnum, IsNotEmpty, IsString, Matches, ValidateNested } from 'class-validator';
	import { UserRole } from '../models/user.model';
	
	export class CreateUserDto {
	    @IsNotEmpty()
	    @IsString()
	    firstName: string;
	
	    @IsNotEmpty()
	    @IsString()
	    lastName: string;
	
	    @IsNotEmpty()
	    @IsEmail()
	    email: string;
	
	    @IsNotEmpty()
	    @IsString()
	    @Matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/, {
	        message:
	            'Password must be at least 8 characters long, contain at least one number, one uppercase letter, one lowercase letter and one special character',
	    })
	    password: string;
	
	    @IsNotEmpty()
	    @IsArray()
	    @IsEnum([UserRole.BUSINESS_OWNER, UserRole.EMPLOYEE], { each: true })
	    roles: UserRole[];
	}
```

modules/users/dto/update-user.ts:
```
	import { PartialType } from '@nestjs/mapped-types';
	import { CreateUserDto } from './create-user';
	
	export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

modules/users/models/user.model.ts:
```
	import { Model, DataTypes, Sequelize } from 'sequelize';
	import { Business } from '../../businesses/models/business.model';
	import { Branch } from '../../branches/models/branch.model';
	import { File } from '../../file-upload/models/file.model';
	import { Activity } from '../../businesses/models/activity.model';
	
	export enum UserRole {
	    ADMIN = 'admin',
	    BUSINESS_OWNER = 'business_owner',
	    EMPLOYEE = 'employee',
	}
	
	export class User extends Model {
	    public declare id: number;
	    public firstName!: string;
	    public lastName!: string;
	    public email!: string;
	    public password!: string;
	    public roles!: UserRole[];
	    public active!: boolean;
	
	    public readonly createdAt!: Date;
	    public readonly updatedAt!: Date;
	
	    declare businesses: Business[];
	    declare employedAt: Branch[];
	}
	
	export const init = (sequelize: Sequelize) =>
	    User.init(
	        {
	            id: {
	                type: DataTypes.INTEGER,
	                autoIncrement: true,
	                primaryKey: true,
	            },
	            firstName: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            lastName: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            email: {
	                type: DataTypes.STRING,
	                allowNull: false,
	                unique: true,
	            },
	            password: {
	                type: DataTypes.STRING,
	                allowNull: false,
	            },
	            roles: {
	                type: DataTypes.ARRAY(DataTypes.STRING),
	                defaultValue: [],
	                allowNull: false,
	                validate: {
	                    notEmpty: true,
	                },
	            },
	            active: {
	                type: DataTypes.BOOLEAN,
	                defaultValue: false,
	                allowNull: false,
	            },
	        },
	        {
	            sequelize,
	            tableName: 'users',
	        },
	    );
	
	export const associate = () => {
	    // User | Business
	    User.hasMany(Business, {
	        foreignKey: 'ownerId',
	        as: 'businesses',
	    });
	
	    // User | Branch
	    User.belongsToMany(Branch, {
	        through: 'UserBranch',
	        as: 'employedAt',
	        foreignKey: 'userId',
	    });
	
	    // User | File
	    User.hasMany(File, {
	        foreignKey: 'userId',
	        as: 'files',
	    });
	
	    // User | Activity
	    User.hasMany(Activity, {
	        foreignKey: 'userId',
	        as: 'activities',
	    });
	};
```

modules/users/services/index.ts:
```
	import { Op } from 'sequelize';
	import { HttpError } from '../../../common';
	import { RequestMod } from '../../../common/interfaces/request.mod';
	import { Branch } from '../../branches/models/branch.model';
	import { Business } from '../../businesses/models/business.model';
	import { User } from '../models/user.model';
	import { CreateUserDto } from '../dto/create-user';
	import { UpdateUserDto } from '../dto/update-user';
	import { hashPassword, sendAccountActivationEmail, verifyUserAccountActivationToken } from '../../../helpers';
	
	export const createUser = (createUserDto: CreateUserDto): Promise<User> => {
	    createUserDto.password = hashPassword(createUserDto.password);
	    const user = new User({ ...createUserDto });
	    return user.save().then(async (user) => {
	        // send account activation email
	        await sendAccountActivationEmail(user);
	
	        return user;
	    });
	};
	
	// only select users who share a business with the logged in user
	export const findAllUsers = async ({
	    limit = 10,
	    offset = 0,
	    req,
	}: {
	    limit: number;
	    offset: number;
	    req: RequestMod;
	}) => {
	    const { businessId, branchId } = req.query;
	
	    if (!businessId && !branchId) throw new HttpError(400, 'businessId or branchId is required');
	    if (businessId && branchId) throw new HttpError(400, 'businessId and branchId cannot be used together');
	
	    if (branchId) return getUsersByBranchId(Number(branchId), limit, offset);
	    return getUsersByBusinessId(Number(businessId), limit, offset);
	};
	
	export const findOneUserById = (userId: number): Promise<User> => {
	    return User.findOne({
	        where: {
	            id: userId,
	        },
	        include: [
	            {
	                model: Business,
	                as: 'businesses',
	            },
	            {
	                model: Branch,
	                as: 'employedAt',
	            },
	        ],
	    });
	};
	
	export const updateUserById = async (userId: number, updateUserDto: UpdateUserDto): Promise<User> => {
	    const user = await findOneUserById(userId);
	    if (!user) throw new HttpError(404, 'User not found');
	
	    if (updateUserDto.password) updateUserDto.password = hashPassword(updateUserDto.password);
	    return user.update(updateUserDto);
	};
	
	export const deleteUserById = async (userId: number) => {
	    const user = await findOneUserById(userId);
	    if (!user) throw new HttpError(404, 'User not found');
	
	    return user.destroy().then(() => ({ message: 'User deleted successfully' }));
	};
	
	function getUsersByBranchId(branchId: number, limit: number, offset: number) {
	    return User.findAndCountAll({
	        include: [
	            {
	                model: Business,
	                as: 'businesses',
	            },
	            {
	                model: Branch,
	                where: {
	                    id: branchId,
	                },
	                required: true,
	                as: 'employedAt',
	            },
	        ],
	        limit,
	        offset,
	    });
	}
	
	function getUsersByBusinessId(businessId: number, limit: number, offset: number) {
	    return User.findAndCountAll({
	        include: [
	            {
	                model: Business,
	                where: {
	                    id: businessId,
	                },
	                as: 'businesses',
	            },
	            {
	                model: Branch,
	                as: 'employedAt',
	            },
	        ],
	        limit,
	        offset,
	    });
	}
	
	export const activateAccount = async (token: string) => {
	    // validate token
	    const userId: string = verifyUserAccountActivationToken(token);
	
	    // find user
	    const user = await User.findOne({
	        where: {
	            id: userId,
	        },
	    });
	    if (!user) throw new HttpError(404, 'User not found');
	
	    // activate user
	    user.active = true;
	
	    return user.save().then(() => ({ message: 'Account activated successfully' }));
	};
	
	export async function requestAccountActivation(user: User) {
	    await sendAccountActivationEmail(user);
	    return { message: 'Account activation email sent successfully' };
	}
```

routes/branches.router.ts:
```
	import express from 'express';
	import { BranchController } from '../modules/branches/controllers/Branches';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateBranchDto } from '../modules/branches/dto/create-branch';
	import { UpdateBranchDto } from '../modules/branches/dto/update-branch';
	
	const branchesRouter = express.Router();
	branchesRouter.post('/', validateMiddleware(CreateBranchDto), BranchController.create);
	branchesRouter.get('/', BranchController.getAll);
	branchesRouter.get('/' + ':id', BranchController.getOne);
	branchesRouter.patch('/' + ':id', validateMiddleware(UpdateBranchDto), BranchController.update);
	branchesRouter.delete('/' + ':id', BranchController.delete);
	export default branchesRouter;
```

routes/businesses.router.ts:
```
	import express from 'express';
	import { BusinessController } from '../modules/businesses/controllers/Business';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateBusinessDto } from '../modules/businesses/dto/create-business';
	import { UpdateBusinessDto } from '../modules/businesses/dto/update-business';
	import cardTemplatesRouter from './card-templates.router';
	import { canUseBusinessId } from '../middlewares/methods/canUseBusinessId.middleware';
	import cardsRouter from './cards.router';
	import menuRouter from './menu.router';
	import eventsRouter from './events.router';
	
	const businessesRouter = express.Router();
	businessesRouter.post('/', validateMiddleware(CreateBusinessDto), BusinessController.create);
	businessesRouter.get('/', BusinessController.getAll);
	businessesRouter.get('/' + ':id', BusinessController.getOne);
	businessesRouter.patch('/' + ':id', validateMiddleware(UpdateBusinessDto), BusinessController.update);
	businessesRouter.delete('/' + ':id', BusinessController.delete);
	
	// Events
	businessesRouter.use('/:businessId/events', canUseBusinessId, eventsRouter);
	
	// Card Templates
	businessesRouter.use('/:businessId/card-templates', canUseBusinessId, cardTemplatesRouter);
	
	// Cards
	businessesRouter.use('/:businessId/cards', cardsRouter);
	
	// Menu
	businessesRouter.use('/:businessId/menu', canUseBusinessId, menuRouter);
	
	export default businessesRouter;
```

routes/card-templates.router.ts:
```
	import { Router } from 'express';
	import { CardTemplateController } from '../modules/card-templates/controllers/CardTemplate';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateCardTemplateDto } from '../modules/card-templates/dto/create-card-template';
	import { UpdateCardTemplateDto } from '../modules/card-templates/dto/update-card-template';
	import { CreateLoyaltyGiftDto } from '../modules/card-templates/dto/create-loyalty-gift.dto';
	
	const cardTemplatesRouter = Router({ mergeParams: true });
	
	// Create Card Template
	cardTemplatesRouter.post('/', validateMiddleware(CreateCardTemplateDto), CardTemplateController.create);
	
	// Get All Card Templates
	cardTemplatesRouter.get('/', CardTemplateController.getAll);
	
	// Get One Card Template by Template ID
	cardTemplatesRouter.get('/:id', CardTemplateController.getOne);
	
	// Update Card Template by Template ID
	cardTemplatesRouter.patch('/:id', validateMiddleware(CreateCardTemplateDto), CardTemplateController.update);
	
	// Delete Card Template by Template ID
	cardTemplatesRouter.delete('/:id', CardTemplateController.delete);
	
	// Add Gift to Loyalty Card Template
	cardTemplatesRouter.post(
	    '/:id/gifts',
	    validateMiddleware(CreateLoyaltyGiftDto),
	    CardTemplateController.addGiftToLoyaltyCardTemplate,
	);
	
	// Update Gift in Loyalty Card Template
	cardTemplatesRouter.patch(
	    '/:id/gifts/:giftId',
	    validateMiddleware(CreateLoyaltyGiftDto),
	    CardTemplateController.updateGiftInLoyaltyCardTemplate,
	);
	
	// Delete Gift from Loyalty Card Template
	cardTemplatesRouter.delete('/:id/gifts/:giftId', CardTemplateController.deleteGiftFromLoyaltyCardTemplate);
	
	export default cardTemplatesRouter;
```

routes/cards.router.ts:
```
	import { Router } from 'express';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { UpdateCardDto } from '../modules/cards/dto/update-card';
	import { CreateCardDto } from '../modules/cards/dto/create-card';
	import { CardController } from '../modules/cards/controllers/Card';
	import { LoyaltyAddSubtractPoints } from '../modules/cards/dto/loyalty-add-subtract-points';
	import { ItemsSubUseDto } from '../modules/cards/dto/items-sub-use';
	import { canUseBusinessId } from '../middlewares/methods/canUseBusinessId.middleware';
	
	const cardsRouter = Router({ mergeParams: true });
	
	// Create Card
	cardsRouter.post('/', validateMiddleware(CreateCardDto), CardController.create);
	
	// Get All Card
	cardsRouter.get('/', canUseBusinessId, CardController.getAll);
	
	// Get One Card by ID
	cardsRouter.get('/:id', canUseBusinessId, CardController.getOne);
	
	// Update Card by ID
	cardsRouter.patch('/:id', canUseBusinessId, validateMiddleware(UpdateCardDto), CardController.update);
	
	// Delete Card by ID
	cardsRouter.delete('/:id', canUseBusinessId, CardController.delete);
	
	// loyalty functions
	cardsRouter.patch('/:id/loyalty/add-points', canUseBusinessId, CardController.loyaltyAddPoints);
	cardsRouter.patch('/:id/loyalty/update-points', canUseBusinessId, CardController.loyaltyUpdatePoints);
	
	// redeem loyalty gift
	cardsRouter.patch('/:id/loyalty/redeem-gift', canUseBusinessId, CardController.loyaltyRedeemGift);
	
	// items subscription functions
	cardsRouter.patch(
	    '/:id/items-subscription/use',
	    canUseBusinessId,
	    validateMiddleware(ItemsSubUseDto),
	    CardController.itemSubscriptionUse,
	);
	
	// scan ticket
	cardsRouter.patch('/:id/scan-ticket', canUseBusinessId, CardController.scanTicket);
	
	export default cardsRouter;
```

routes/events.router.ts:
```
	import { Router } from 'express';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { EventsController } from '../modules/events/controllers/events';
	import { CreateEventDto } from '../modules/events/dto/create-event';
	import { UpdateEventDto } from '../modules/events/dto/update-event';
	
	const menuRouter = Router({ mergeParams: true });
	
	// Create Events
	menuRouter.post('/', validateMiddleware(CreateEventDto), EventsController.create);
	
	// find one
	menuRouter.get('/:eventId', EventsController.getOne);
	
	// Get menu
	menuRouter.get('/', EventsController.getAll);
	
	// Update menu item
	menuRouter.patch('/:eventId', validateMiddleware(UpdateEventDto), EventsController.update);
	
	// Delete menu item
	menuRouter.delete('/:eventId', EventsController.delete);
	
	export default menuRouter;
```

routes/file-upload.router.ts:
```
	import express from 'express';
	import { FileUploadController } from '../modules/file-upload/controllers/file-upload.controller';
	
	const fileUploadRouter = express.Router();
	fileUploadRouter.post('/', FileUploadController.create);
	fileUploadRouter.get('/', FileUploadController.list);
	fileUploadRouter.get('/:id', FileUploadController.getFile);
	fileUploadRouter.delete('/:id', FileUploadController.delete);
	export default fileUploadRouter;
```

routes/index.ts:
```
	import express from 'express';
	import { AuthController } from '../modules/auth/controllers/Auth';
	import { UsersController } from '../modules/users/controllers/Users';
	import usersRouter from './users.router';
	import businessesRouter from './businesses.router';
	import branchesRouter from './branches.router';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateUserDto } from '../modules/users/dto/create-user';
	import { CardController } from '../modules/cards/controllers/Card';
	import fileUploadRouter from './file-upload.router';
	import notificationsRouter from './notifications.router';
	import statisticsRouter from './statistics.router';
	
	const mainRouter = express.Router();
	mainRouter.post('/register', validateMiddleware(CreateUserDto), UsersController.create);
	mainRouter.post('/login', AuthController.login);
	mainRouter.get('/activate-account/:token', UsersController.activateAccount);
	mainRouter.post('/request-account-activation', UsersController.requestAccountActivation);
	
	mainRouter.use('/users', usersRouter);
	mainRouter.use('/businesses', businessesRouter);
	mainRouter.use('/branches', branchesRouter);
	mainRouter.use('/notifications', notificationsRouter);
	mainRouter.use('/statistics', statisticsRouter);
	
	// Get Card Info by ID
	mainRouter.get('/card-info/:id', CardController.getOne);
	
	// file upload
	mainRouter.use('/file-upload', fileUploadRouter);
	
	// register apple pass device
	mainRouter.post(
	    '/v1/devices/:deviceLibraryIdentifier/registrations/:passTypeIdentifier/:serialNumber',
	    CardController.registerDevice,
	);
	
	// Unregister a Pass for Update Notifications
	mainRouter.delete(
	    '/v1/devices/:deviceLibraryIdentifier/registrations/:passTypeIdentifier/:serialNumber',
	    CardController.unregisterDevice,
	);
	
	// Getting the Serial Numbers for Passes Associated with a Device
	mainRouter.get(
	    '/v1/devices/:deviceLibraryIdentifier/registrations/:passTypeIdentifier',
	    CardController.getSerialNumbers,
	);
	
	// Send an Updated Pass
	mainRouter.get('/v1/passes/:passTypeIdentifier/:serialNumber', CardController.sendUpdatedPass);
	
	// pass log
	mainRouter.post('/v1/log', CardController.log);
	
	export default mainRouter;
```

routes/menu.router.ts:
```
	import { Router } from 'express';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateMenuDto, MenuItemDto } from '../modules/businesses/dto/create-menu';
	import { MenuController } from '../modules/businesses/controllers/menu';
	
	const menuRouter = Router({ mergeParams: true });
	
	// Create Menu
	menuRouter.post('/', validateMiddleware(CreateMenuDto), MenuController.createMenu);
	
	// Get menu
	menuRouter.get('/', MenuController.getMenu);
	
	// Update menu item
	menuRouter.patch('/:menuItemId', validateMiddleware(MenuItemDto), MenuController.updateMenuItem);
	
	// Delete menu item
	menuRouter.delete('/:menuItemId', MenuController.deleteMenuItem);
	
	// Delete menu
	menuRouter.delete('/', MenuController.deleteMenu);
	
	// Add menu items
	menuRouter.post('/add', validateMiddleware(CreateMenuDto), MenuController.addMenuItems);
	
	export default menuRouter;
```

routes/notifications.router.ts:
```
	import express from 'express';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateCardNotificationDto } from '../modules/notifications/dto/create-notification';
	import { NotificationsController } from '../modules/notifications/controllers/notifications.controller';
	
	const notificationsRouter = express.Router();
	notificationsRouter.post(
	    '/card-notification',
	    validateMiddleware(CreateCardNotificationDto),
	    NotificationsController.createCardNotification,
	);
	export default notificationsRouter;
```

routes/statistics.router.ts:
```
	import express from 'express';
	import { StatisticsController } from '../modules/statistics/controllers/statistics.controller';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { GetCardsQueryDto } from '../modules/statistics/dto/get-cards.query.dto';
	import { GetCardsTotalQueryDto } from '../modules/statistics/dto/get-cards-total.query.dto';
	import { GetCardsChartQueryDto } from '../modules/statistics/dto/get-cards-chart.query.dto';
	import { GetCardsRewardsRedeemedChartQueryDto } from '../modules/statistics/dto/get-cards-rewards-redeemed-chart.query.dto';
	import { GetActivitiesQueryDto } from '../modules/statistics/dto/get-activities.query.dto';
	import { GetActivitiesChartQueryDto } from '../modules/statistics/dto/get-activities-chart.query.dto';
	
	const statisticsRouter = express.Router();
	statisticsRouter.get('/cards', validateMiddleware(GetCardsQueryDto, true), StatisticsController.getCardStatistics);
	statisticsRouter.get(
	    '/cards/total',
	    validateMiddleware(GetCardsTotalQueryDto, true),
	    StatisticsController.getCardsTotal,
	);
	statisticsRouter.get(
	    '/cards/chart',
	    validateMiddleware(GetCardsChartQueryDto, true),
	    StatisticsController.getCardsChart,
	);
	statisticsRouter.get(
	    '/cards/rewards-redeemed/chart',
	    validateMiddleware(GetCardsRewardsRedeemedChartQueryDto, true),
	    StatisticsController.getCardsRewardsRedeemedChart,
	);
	statisticsRouter.get(
	    '/activities',
	    validateMiddleware(GetActivitiesQueryDto, true),
	    StatisticsController.getActivities,
	);
	statisticsRouter.get(
	    '/activities/chart',
	    validateMiddleware(GetActivitiesChartQueryDto, true),
	    StatisticsController.getActivitiesChart,
	);
	export default statisticsRouter;
```

routes/users.router.ts:
```
	import express from 'express';
	import { UsersController } from '../modules/users/controllers/Users';
	import { validateMiddleware } from '../middlewares/methods/validate.middleware';
	import { CreateUserDto } from '../modules/users/dto/create-user';
	import { UpdateUserDto } from '../modules/users/dto/update-user';
	
	const usersRouter = express.Router();
	
	// CRUD routes
	usersRouter.post('/', validateMiddleware(CreateUserDto), UsersController.create);
	usersRouter.get('/', UsersController.getAll);
	usersRouter.get('/' + ':id', UsersController.getOne);
	usersRouter.patch('/' + ':id', validateMiddleware(UpdateUserDto), UsersController.update);
	usersRouter.delete('/' + ':id', UsersController.delete);
	
	export default usersRouter;
```

